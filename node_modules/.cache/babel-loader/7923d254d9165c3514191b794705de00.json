{"ast":null,"code":"\"use strict\";\n/**\n * @module compiler/validator\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nconst pope_1 = require(\"pope\");\n\nconst lodash_set_1 = __importDefault(require(\"lodash.set\"));\n/**\n * Collector collects all the errors and creates a copy of validated\n * data (only when `generateTree = true`).\n */\n\n\nclass Collector {\n  constructor(formatter, generateTree, customErrorCollector) {\n    this.formatter = formatter;\n    this.generateTree = generateTree;\n    this.customErrorCollector = customErrorCollector;\n    this.tree = {};\n    this.hasErrors = false;\n  }\n  /**\n   * Set value of a given node. The function results in a noop\n   * when `value === undefined` or the validation chain has\n   * one or more errors.\n   */\n\n\n  setValue(pointer, value) {\n    if (!this.generateTree || value === undefined || this.hasErrors) {\n      return;\n    }\n\n    pointer = pointer.replace('.::tip::', '');\n    lodash_set_1.default(this.tree, pointer, value);\n  }\n  /**\n   * Returns the collected data\n   */\n\n\n  getData() {\n    return this.tree;\n  }\n  /**\n   * Returns errors from the formatter\n   */\n\n\n  getErrors() {\n    return this.formatter.toJSON();\n  }\n  /**\n   * Passes error to the error formatter for a given field and rule.\n   * Also when the message is undefined, it will create a generic\n   * message.\n   */\n\n\n  setError(pointer, rule, message) {\n    this.hasErrors = true;\n\n    if (message && typeof message === 'string') {\n      message = pope_1.pope(message, {\n        field: pointer,\n        args: rule.args,\n        validation: rule.name\n      });\n    }\n\n    message = message || `${rule.name} validation failed on ${pointer}`;\n    message = typeof message === 'function' ? message(pointer, rule.name, rule.args) : message;\n    /**\n     * When custom error collector is defined, then we let it handle then\n     * error, otherwise we report it to the formatter ourselves\n     */\n\n    if (typeof this.customErrorCollector === 'function') {\n      this.customErrorCollector(this.formatter, message, pointer, rule.name, rule.args);\n    } else {\n      /**\n       * Report error to the formatter\n       */\n      this.formatter.addError(message, pointer, rule.name, rule.args);\n    }\n  }\n\n}\n\nexports.Collector = Collector;","map":{"version":3,"sources":["/opt/lampp/htdocs/react-blog/node_modules/indicative-compiler/build/src/Validator/Collector.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","pope_1","require","lodash_set_1","Collector","constructor","formatter","generateTree","customErrorCollector","tree","hasErrors","setValue","pointer","undefined","replace","default","getData","getErrors","toJSON","setError","rule","message","pope","field","args","validation","name","addError"],"mappings":"AAAA;AACA;;;;AAGA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA;;;;;;;;;AAQA,MAAMC,MAAM,GAAGC,OAAO,CAAC,MAAD,CAAtB;;AACA,MAAMC,YAAY,GAAGT,eAAe,CAACQ,OAAO,CAAC,YAAD,CAAR,CAApC;AACA;;;;;;AAIA,MAAME,SAAN,CAAgB;AACZC,EAAAA,WAAW,CAACC,SAAD,EAAYC,YAAZ,EAA0BC,oBAA1B,EAAgD;AACvD,SAAKF,SAAL,GAAiBA,SAAjB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,oBAAL,GAA4BA,oBAA5B;AACA,SAAKC,IAAL,GAAY,EAAZ;AACA,SAAKC,SAAL,GAAiB,KAAjB;AACH;AACD;;;;;;;AAKAC,EAAAA,QAAQ,CAACC,OAAD,EAAUZ,KAAV,EAAiB;AACrB,QAAI,CAAC,KAAKO,YAAN,IAAsBP,KAAK,KAAKa,SAAhC,IAA6C,KAAKH,SAAtD,EAAiE;AAC7D;AACH;;AACDE,IAAAA,OAAO,GAAGA,OAAO,CAACE,OAAR,CAAgB,UAAhB,EAA4B,EAA5B,CAAV;AACAX,IAAAA,YAAY,CAACY,OAAb,CAAqB,KAAKN,IAA1B,EAAgCG,OAAhC,EAAyCZ,KAAzC;AACH;AACD;;;;;AAGAgB,EAAAA,OAAO,GAAG;AACN,WAAO,KAAKP,IAAZ;AACH;AACD;;;;;AAGAQ,EAAAA,SAAS,GAAG;AACR,WAAO,KAAKX,SAAL,CAAeY,MAAf,EAAP;AACH;AACD;;;;;;;AAKAC,EAAAA,QAAQ,CAACP,OAAD,EAAUQ,IAAV,EAAgBC,OAAhB,EAAyB;AAC7B,SAAKX,SAAL,GAAiB,IAAjB;;AACA,QAAIW,OAAO,IAAI,OAAQA,OAAR,KAAqB,QAApC,EAA8C;AAC1CA,MAAAA,OAAO,GAAGpB,MAAM,CAACqB,IAAP,CAAYD,OAAZ,EAAqB;AAC3BE,QAAAA,KAAK,EAAEX,OADoB;AAE3BY,QAAAA,IAAI,EAAEJ,IAAI,CAACI,IAFgB;AAG3BC,QAAAA,UAAU,EAAEL,IAAI,CAACM;AAHU,OAArB,CAAV;AAKH;;AACDL,IAAAA,OAAO,GAAGA,OAAO,IAAK,GAAED,IAAI,CAACM,IAAK,yBAAwBd,OAAQ,EAAlE;AACAS,IAAAA,OAAO,GAAG,OAAQA,OAAR,KAAqB,UAArB,GAAkCA,OAAO,CAACT,OAAD,EAAUQ,IAAI,CAACM,IAAf,EAAqBN,IAAI,CAACI,IAA1B,CAAzC,GAA2EH,OAArF;AACA;;;;;AAIA,QAAI,OAAQ,KAAKb,oBAAb,KAAuC,UAA3C,EAAuD;AACnD,WAAKA,oBAAL,CAA0B,KAAKF,SAA/B,EAA0Ce,OAA1C,EAAmDT,OAAnD,EAA4DQ,IAAI,CAACM,IAAjE,EAAuEN,IAAI,CAACI,IAA5E;AACH,KAFD,MAGK;AACD;;;AAGA,WAAKlB,SAAL,CAAeqB,QAAf,CAAwBN,OAAxB,EAAiCT,OAAjC,EAA0CQ,IAAI,CAACM,IAA/C,EAAqDN,IAAI,CAACI,IAA1D;AACH;AACJ;;AA7DW;;AA+DhBzB,OAAO,CAACK,SAAR,GAAoBA,SAApB","sourcesContent":["\"use strict\";\n/**\n * @module compiler/validator\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst pope_1 = require(\"pope\");\nconst lodash_set_1 = __importDefault(require(\"lodash.set\"));\n/**\n * Collector collects all the errors and creates a copy of validated\n * data (only when `generateTree = true`).\n */\nclass Collector {\n    constructor(formatter, generateTree, customErrorCollector) {\n        this.formatter = formatter;\n        this.generateTree = generateTree;\n        this.customErrorCollector = customErrorCollector;\n        this.tree = {};\n        this.hasErrors = false;\n    }\n    /**\n     * Set value of a given node. The function results in a noop\n     * when `value === undefined` or the validation chain has\n     * one or more errors.\n     */\n    setValue(pointer, value) {\n        if (!this.generateTree || value === undefined || this.hasErrors) {\n            return;\n        }\n        pointer = pointer.replace('.::tip::', '');\n        lodash_set_1.default(this.tree, pointer, value);\n    }\n    /**\n     * Returns the collected data\n     */\n    getData() {\n        return this.tree;\n    }\n    /**\n     * Returns errors from the formatter\n     */\n    getErrors() {\n        return this.formatter.toJSON();\n    }\n    /**\n     * Passes error to the error formatter for a given field and rule.\n     * Also when the message is undefined, it will create a generic\n     * message.\n     */\n    setError(pointer, rule, message) {\n        this.hasErrors = true;\n        if (message && typeof (message) === 'string') {\n            message = pope_1.pope(message, {\n                field: pointer,\n                args: rule.args,\n                validation: rule.name,\n            });\n        }\n        message = message || `${rule.name} validation failed on ${pointer}`;\n        message = typeof (message) === 'function' ? message(pointer, rule.name, rule.args) : message;\n        /**\n         * When custom error collector is defined, then we let it handle then\n         * error, otherwise we report it to the formatter ourselves\n         */\n        if (typeof (this.customErrorCollector) === 'function') {\n            this.customErrorCollector(this.formatter, message, pointer, rule.name, rule.args);\n        }\n        else {\n            /**\n             * Report error to the formatter\n             */\n            this.formatter.addError(message, pointer, rule.name, rule.args);\n        }\n    }\n}\nexports.Collector = Collector;\n"]},"metadata":{},"sourceType":"script"}