{"ast":null,"code":"\"use strict\";\n/**\n * @module compiler/validator\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nconst Collector_1 = require(\"./Collector\");\n/**\n * Executor is meant to execute the compiled functions with runtime\n * data.\n */\n\n\nclass Executor {\n  constructor(fns) {\n    this.fns = fns;\n  }\n  /**\n   * Executes the compiled functions in sequence.\n   */\n\n\n  async exec(data, Formatter, config, bail, removeAdditional, customErrorCollector) {\n    /**\n     * Creating a root data node. The `tip` and `pointer` will be copied\n     * and mutated down the road\n     */\n    const root = {\n      tip: data,\n      original: data,\n      pointer: ''\n    };\n    /**\n     * Collector to collect errors and a fresh data object with only\n     * validated data (relies on removeAdditional though)\n     */\n\n    const collector = new Collector_1.Collector(new Formatter(), removeAdditional, customErrorCollector);\n\n    for (let fn of this.fns) {\n      let passed = false;\n\n      if (fn.async) {\n        passed = await fn.execAsync(root, collector, config, bail);\n      } else {\n        passed = fn.exec(root, collector, config, bail);\n      }\n\n      if (!passed && bail) {\n        break;\n      }\n    }\n\n    const errors = collector.getErrors();\n    /**\n     * If passed, return the data\n     */\n\n    if (!errors) {\n      return removeAdditional ? collector.getData() : data;\n    }\n    /**\n     * Otherwise return errors\n     */\n\n\n    throw errors;\n  }\n\n}\n\nexports.Executor = Executor;","map":{"version":3,"sources":["/opt/lampp/htdocs/react-blog/node_modules/indicative-compiler/build/src/Validator/Executor.js"],"names":["Object","defineProperty","exports","value","Collector_1","require","Executor","constructor","fns","exec","data","Formatter","config","bail","removeAdditional","customErrorCollector","root","tip","original","pointer","collector","Collector","fn","passed","async","execAsync","errors","getErrors","getData"],"mappings":"AAAA;AACA;;;;AAGAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA;;;;;;;;;AAQA,MAAMC,WAAW,GAAGC,OAAO,CAAC,aAAD,CAA3B;AACA;;;;;;AAIA,MAAMC,QAAN,CAAe;AACXC,EAAAA,WAAW,CAACC,GAAD,EAAM;AACb,SAAKA,GAAL,GAAWA,GAAX;AACH;AACD;;;;;AAGA,QAAMC,IAAN,CAAWC,IAAX,EAAiBC,SAAjB,EAA4BC,MAA5B,EAAoCC,IAApC,EAA0CC,gBAA1C,EAA4DC,oBAA5D,EAAkF;AAC9E;;;;AAIA,UAAMC,IAAI,GAAG;AAAEC,MAAAA,GAAG,EAAEP,IAAP;AAAaQ,MAAAA,QAAQ,EAAER,IAAvB;AAA6BS,MAAAA,OAAO,EAAE;AAAtC,KAAb;AACA;;;;;AAIA,UAAMC,SAAS,GAAG,IAAIhB,WAAW,CAACiB,SAAhB,CAA0B,IAAIV,SAAJ,EAA1B,EAA2CG,gBAA3C,EAA6DC,oBAA7D,CAAlB;;AACA,SAAK,IAAIO,EAAT,IAAe,KAAKd,GAApB,EAAyB;AACrB,UAAIe,MAAM,GAAG,KAAb;;AACA,UAAID,EAAE,CAACE,KAAP,EAAc;AACVD,QAAAA,MAAM,GAAG,MAAMD,EAAE,CAACG,SAAH,CAAaT,IAAb,EAAmBI,SAAnB,EAA8BR,MAA9B,EAAsCC,IAAtC,CAAf;AACH,OAFD,MAGK;AACDU,QAAAA,MAAM,GAAGD,EAAE,CAACb,IAAH,CAAQO,IAAR,EAAcI,SAAd,EAAyBR,MAAzB,EAAiCC,IAAjC,CAAT;AACH;;AACD,UAAI,CAACU,MAAD,IAAWV,IAAf,EAAqB;AACjB;AACH;AACJ;;AACD,UAAMa,MAAM,GAAGN,SAAS,CAACO,SAAV,EAAf;AACA;;;;AAGA,QAAI,CAACD,MAAL,EAAa;AACT,aAAOZ,gBAAgB,GAAGM,SAAS,CAACQ,OAAV,EAAH,GAAyBlB,IAAhD;AACH;AACD;;;;;AAGA,UAAMgB,MAAN;AACH;;AAzCU;;AA2CfxB,OAAO,CAACI,QAAR,GAAmBA,QAAnB","sourcesContent":["\"use strict\";\n/**\n * @module compiler/validator\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst Collector_1 = require(\"./Collector\");\n/**\n * Executor is meant to execute the compiled functions with runtime\n * data.\n */\nclass Executor {\n    constructor(fns) {\n        this.fns = fns;\n    }\n    /**\n     * Executes the compiled functions in sequence.\n     */\n    async exec(data, Formatter, config, bail, removeAdditional, customErrorCollector) {\n        /**\n         * Creating a root data node. The `tip` and `pointer` will be copied\n         * and mutated down the road\n         */\n        const root = { tip: data, original: data, pointer: '' };\n        /**\n         * Collector to collect errors and a fresh data object with only\n         * validated data (relies on removeAdditional though)\n         */\n        const collector = new Collector_1.Collector(new Formatter(), removeAdditional, customErrorCollector);\n        for (let fn of this.fns) {\n            let passed = false;\n            if (fn.async) {\n                passed = await fn.execAsync(root, collector, config, bail);\n            }\n            else {\n                passed = fn.exec(root, collector, config, bail);\n            }\n            if (!passed && bail) {\n                break;\n            }\n        }\n        const errors = collector.getErrors();\n        /**\n         * If passed, return the data\n         */\n        if (!errors) {\n            return removeAdditional ? collector.getData() : data;\n        }\n        /**\n         * Otherwise return errors\n         */\n        throw errors;\n    }\n}\nexports.Executor = Executor;\n"]},"metadata":{},"sourceType":"script"}