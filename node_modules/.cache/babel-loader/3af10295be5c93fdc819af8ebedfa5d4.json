{"ast":null,"code":"\"use strict\";\n/*\n * indicative-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar getBaseRules_1 = require(\"./getBaseRules\");\n/**\n * Returns runtime node for an array type.\n */\n\n\nfunction getTupleType(schemas, isOptional, rules) {\n  return {\n    getTree: function getTree() {\n      var payload = {\n        type: 'array',\n        rules: getBaseRules_1.getBaseRules('array', isOptional).concat([{\n          name: 'size',\n          args: [schemas.length]\n        }]) // Enforce length\n        .concat(rules),\n        each: {}\n      };\n      schemas.forEach(function (schema, index) {\n        var children = schema.getTree();\n\n        if (children.type === 'array') {\n          throw new Error('2d arrays are currently not supported');\n        }\n\n        payload.each[index] = {\n          /**\n           * Nodes of array cannot be marked as required and hence `size`\n           * rule must be used on array for same\n           */\n          rules: children.rules.filter(function (_ref) {\n            var name = _ref.name;\n            return name !== 'required';\n          }),\n          children: children.type === 'object' ? children.children : {}\n        };\n      });\n      return payload;\n    }\n  };\n}\n\nexports.getTupleType = getTupleType;","map":{"version":3,"sources":["/opt/lampp/htdocs/react-blog/node_modules/indicative-parser/build/src/utils/getTupleType.js"],"names":["Object","defineProperty","exports","value","getBaseRules_1","require","getTupleType","schemas","isOptional","rules","getTree","payload","type","getBaseRules","concat","name","args","length","each","forEach","schema","index","children","Error","filter"],"mappings":"AAAA;AACA;;;;;;;;;AAQAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAMC,cAAc,GAAGC,OAAO,CAAC,gBAAD,CAA9B;AACA;;;;;AAGA,SAASC,YAAT,CAAsBC,OAAtB,EAA+BC,UAA/B,EAA2CC,KAA3C,EAAkD;AAC9C,SAAO;AACHC,IAAAA,OADG,qBACO;AACN,UAAMC,OAAO,GAAG;AACZC,QAAAA,IAAI,EAAE,OADM;AAEZH,QAAAA,KAAK,EAAEL,cAAc,CAACS,YAAf,CAA4B,OAA5B,EAAqCL,UAArC,EACFM,MADE,CACK,CAAC;AAAEC,UAAAA,IAAI,EAAE,MAAR;AAAgBC,UAAAA,IAAI,EAAE,CAACT,OAAO,CAACU,MAAT;AAAtB,SAAD,CADL,EACiD;AADjD,SAEFH,MAFE,CAEKL,KAFL,CAFK;AAKZS,QAAAA,IAAI,EAAE;AALM,OAAhB;AAOAX,MAAAA,OAAO,CAACY,OAAR,CAAgB,UAACC,MAAD,EAASC,KAAT,EAAmB;AAC/B,YAAMC,QAAQ,GAAGF,MAAM,CAACV,OAAP,EAAjB;;AACA,YAAIY,QAAQ,CAACV,IAAT,KAAkB,OAAtB,EAA+B;AAC3B,gBAAM,IAAIW,KAAJ,CAAU,uCAAV,CAAN;AACH;;AACDZ,QAAAA,OAAO,CAACO,IAAR,CAAaG,KAAb,IAAsB;AAClB;;;;AAIAZ,UAAAA,KAAK,EAAEa,QAAQ,CAACb,KAAT,CAAee,MAAf,CAAsB;AAAA,gBAAGT,IAAH,QAAGA,IAAH;AAAA,mBAAcA,IAAI,KAAK,UAAvB;AAAA,WAAtB,CALW;AAMlBO,UAAAA,QAAQ,EAAEA,QAAQ,CAACV,IAAT,KAAkB,QAAlB,GAA6BU,QAAQ,CAACA,QAAtC,GAAiD;AANzC,SAAtB;AAQH,OAbD;AAcA,aAAOX,OAAP;AACH;AAxBE,GAAP;AA0BH;;AACDT,OAAO,CAACI,YAAR,GAAuBA,YAAvB","sourcesContent":["\"use strict\";\n/*\n * indicative-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst getBaseRules_1 = require(\"./getBaseRules\");\n/**\n * Returns runtime node for an array type.\n */\nfunction getTupleType(schemas, isOptional, rules) {\n    return {\n        getTree() {\n            const payload = {\n                type: 'array',\n                rules: getBaseRules_1.getBaseRules('array', isOptional)\n                    .concat([{ name: 'size', args: [schemas.length] }]) // Enforce length\n                    .concat(rules),\n                each: {},\n            };\n            schemas.forEach((schema, index) => {\n                const children = schema.getTree();\n                if (children.type === 'array') {\n                    throw new Error('2d arrays are currently not supported');\n                }\n                payload.each[index] = {\n                    /**\n                     * Nodes of array cannot be marked as required and hence `size`\n                     * rule must be used on array for same\n                     */\n                    rules: children.rules.filter(({ name }) => name !== 'required'),\n                    children: children.type === 'object' ? children.children : {},\n                };\n            });\n            return payload;\n        },\n    };\n}\nexports.getTupleType = getTupleType;\n"]},"metadata":{},"sourceType":"script"}