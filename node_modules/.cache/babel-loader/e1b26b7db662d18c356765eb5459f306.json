{"ast":null,"code":"\"use strict\";\n/**\n * @module compiler/validator\n */\n\nvar _regeneratorRuntime = require(\"/opt/lampp/htdocs/blog-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/opt/lampp/htdocs/blog-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/opt/lampp/htdocs/blog-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/lampp/htdocs/blog-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nvar Collector_1 = require(\"./Collector\");\n/**\n * Executor is meant to execute the compiled functions with runtime\n * data.\n */\n\n\nvar Executor =\n/*#__PURE__*/\nfunction () {\n  function Executor(fns) {\n    _classCallCheck(this, Executor);\n\n    this.fns = fns;\n  }\n  /**\n   * Executes the compiled functions in sequence.\n   */\n\n\n  _createClass(Executor, [{\n    key: \"exec\",\n    value: function () {\n      var _exec = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(data, Formatter, config, bail, removeAdditional, customErrorCollector) {\n        var root, collector, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, fn, passed, errors;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                /**\n                 * Creating a root data node. The `tip` and `pointer` will be copied\n                 * and mutated down the road\n                 */\n                root = {\n                  tip: data,\n                  original: data,\n                  pointer: ''\n                };\n                /**\n                 * Collector to collect errors and a fresh data object with only\n                 * validated data (relies on removeAdditional though)\n                 */\n\n                collector = new Collector_1.Collector(new Formatter(), removeAdditional, customErrorCollector);\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _iteratorError = undefined;\n                _context.prev = 5;\n                _iterator = this.fns[Symbol.iterator]();\n\n              case 7:\n                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                  _context.next = 22;\n                  break;\n                }\n\n                fn = _step.value;\n                passed = false;\n\n                if (!fn.async) {\n                  _context.next = 16;\n                  break;\n                }\n\n                _context.next = 13;\n                return fn.execAsync(root, collector, config, bail);\n\n              case 13:\n                passed = _context.sent;\n                _context.next = 17;\n                break;\n\n              case 16:\n                passed = fn.exec(root, collector, config, bail);\n\n              case 17:\n                if (!(!passed && bail)) {\n                  _context.next = 19;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 22);\n\n              case 19:\n                _iteratorNormalCompletion = true;\n                _context.next = 7;\n                break;\n\n              case 22:\n                _context.next = 28;\n                break;\n\n              case 24:\n                _context.prev = 24;\n                _context.t0 = _context[\"catch\"](5);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 28:\n                _context.prev = 28;\n                _context.prev = 29;\n\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n\n              case 31:\n                _context.prev = 31;\n\n                if (!_didIteratorError) {\n                  _context.next = 34;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 34:\n                return _context.finish(31);\n\n              case 35:\n                return _context.finish(28);\n\n              case 36:\n                errors = collector.getErrors();\n                /**\n                 * If passed, return the data\n                 */\n\n                if (errors) {\n                  _context.next = 39;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", removeAdditional ? collector.getData() : data);\n\n              case 39:\n                throw errors;\n\n              case 40:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 24, 28, 36], [29,, 31, 35]]);\n      }));\n\n      function exec(_x, _x2, _x3, _x4, _x5, _x6) {\n        return _exec.apply(this, arguments);\n      }\n\n      return exec;\n    }()\n  }]);\n\n  return Executor;\n}();\n\nexports.Executor = Executor;","map":{"version":3,"sources":["/opt/lampp/htdocs/blog-app/node_modules/indicative-compiler/build/src/Validator/Executor.js"],"names":["Object","defineProperty","exports","value","Collector_1","require","Executor","fns","data","Formatter","config","bail","removeAdditional","customErrorCollector","root","tip","original","pointer","collector","Collector","fn","passed","async","execAsync","exec","errors","getErrors","getData"],"mappings":"AAAA;AACA;;;;;;;;;;;;AAGAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA;;;;;;;;;AAQA,IAAMC,WAAW,GAAGC,OAAO,CAAC,aAAD,CAA3B;AACA;;;;;;IAIMC,Q;;;AACF,oBAAYC,GAAZ,EAAiB;AAAA;;AACb,SAAKA,GAAL,GAAWA,GAAX;AACH;AACD;;;;;;;;;;gDAGWC,I,EAAMC,S,EAAWC,M,EAAQC,I,EAAMC,gB,EAAkBC,oB;;;;;;;AACxD;;;;AAIMC,gBAAAA,I,GAAO;AAAEC,kBAAAA,GAAG,EAAEP,IAAP;AAAaQ,kBAAAA,QAAQ,EAAER,IAAvB;AAA6BS,kBAAAA,OAAO,EAAE;AAAtC,iB;AACb;;;;;AAIMC,gBAAAA,S,GAAY,IAAId,WAAW,CAACe,SAAhB,CAA0B,IAAIV,SAAJ,EAA1B,EAA2CG,gBAA3C,EAA6DC,oBAA7D,C;;;;;4BACH,KAAKN,G;;;;;;;;AAAXa,gBAAAA,E;AACDC,gBAAAA,M,GAAS,K;;qBACTD,EAAE,CAACE,K;;;;;;uBACYF,EAAE,CAACG,SAAH,CAAaT,IAAb,EAAmBI,SAAnB,EAA8BR,MAA9B,EAAsCC,IAAtC,C;;;AAAfU,gBAAAA,M;;;;;AAGAA,gBAAAA,MAAM,GAAGD,EAAE,CAACI,IAAH,CAAQV,IAAR,EAAcI,SAAd,EAAyBR,MAAzB,EAAiCC,IAAjC,CAAT;;;sBAEA,CAACU,MAAD,IAAWV,I;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIbc,gBAAAA,M,GAASP,SAAS,CAACQ,SAAV,E;AACf;;;;oBAGKD,M;;;;;iDACMb,gBAAgB,GAAGM,SAAS,CAACS,OAAV,EAAH,GAAyBnB,I;;;sBAK9CiB,M;;;;;;;;;;;;;;;;;;;;;AAGdvB,OAAO,CAACI,QAAR,GAAmBA,QAAnB","sourcesContent":["\"use strict\";\n/**\n * @module compiler/validator\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst Collector_1 = require(\"./Collector\");\n/**\n * Executor is meant to execute the compiled functions with runtime\n * data.\n */\nclass Executor {\n    constructor(fns) {\n        this.fns = fns;\n    }\n    /**\n     * Executes the compiled functions in sequence.\n     */\n    async exec(data, Formatter, config, bail, removeAdditional, customErrorCollector) {\n        /**\n         * Creating a root data node. The `tip` and `pointer` will be copied\n         * and mutated down the road\n         */\n        const root = { tip: data, original: data, pointer: '' };\n        /**\n         * Collector to collect errors and a fresh data object with only\n         * validated data (relies on removeAdditional though)\n         */\n        const collector = new Collector_1.Collector(new Formatter(), removeAdditional, customErrorCollector);\n        for (let fn of this.fns) {\n            let passed = false;\n            if (fn.async) {\n                passed = await fn.execAsync(root, collector, config, bail);\n            }\n            else {\n                passed = fn.exec(root, collector, config, bail);\n            }\n            if (!passed && bail) {\n                break;\n            }\n        }\n        const errors = collector.getErrors();\n        /**\n         * If passed, return the data\n         */\n        if (!errors) {\n            return removeAdditional ? collector.getData() : data;\n        }\n        /**\n         * Otherwise return errors\n         */\n        throw errors;\n    }\n}\nexports.Executor = Executor;\n"]},"metadata":{},"sourceType":"script"}