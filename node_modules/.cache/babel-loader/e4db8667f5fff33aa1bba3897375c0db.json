{"ast":null,"code":"\"use strict\";\n/**\n * @module compiler/sanitizer\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nconst isobject_1 = __importDefault(require(\"isobject\"));\n\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Runs an array of sanitizations on a given field.\n */\n\n\nclass SanitizationsRunner {\n  constructor(field, dotPath, rules, sanitizations) {\n    this.field = field;\n    this.dotPath = dotPath;\n    this.sanitizations = [];\n    this.computeSanitizations(sanitizations, rules);\n  }\n  /**\n   * Pull sanitizations for the list defined rules.\n   */\n\n\n  computeSanitizations(sanitizations, rules) {\n    this.sanitizations = rules.map(rule => {\n      const sanitization = sanitizations[rule.name];\n      /**\n       * Raise exception when sanitization implementation for a\n       * given rule is missing.\n       */\n\n      if (!sanitization) {\n        throw new Error(`${rule.name} is not a registered as a sanitization`);\n      }\n      /**\n       * The sanitization node must have a `validate` function.\n       */\n\n\n      if (typeof sanitization.sanitize !== 'function') {\n        throw new Error(`${rule.name} is missing sanitize function`);\n      }\n      /**\n       * Mutate args when `compile` function is defined. It is a way to\n       * normalize arguments before the sanitization process kicks in.\n       */\n\n\n      if (typeof sanitization.compile === 'function') {\n        rule.args = sanitization.compile(rule.args);\n      }\n\n      return {\n        rule: rule,\n        fn: sanitization.sanitize\n      };\n    });\n  }\n  /**\n   * Returns a fresh data copy by copying some of the values from the actual\n   * data and then mutating the `tip` and `pointer`. The tip and pointer\n   * are mutated so that the sanitization function receives the closest\n   * object from the pointer, resulting in performant code.\n   */\n\n\n  getDataCopy(data) {\n    const tip = this.dotPath.length ? lodash_get_1.default(data.tip, this.dotPath) : data.tip;\n    /**\n     * Updating the tip and pointer\n     */\n\n    return Object.assign({}, data, {\n      tip: this.field === '::tip::' ? {\n        [this.field]: tip\n      } : tip\n    });\n  }\n  /**\n   * Execute all sanitization in series for a given filed\n   */\n\n\n  exec(data, config) {\n    const dataCopy = this.getDataCopy(data);\n    /**\n     * Skip validations when the parent value of this field is not\n     * an object. The user must validate the parent to be object\n     * seperately.\n     */\n\n    if (!isobject_1.default(dataCopy.tip)) {\n      return;\n    }\n\n    this.sanitizations.forEach(sanitization => {\n      sanitization.fn(dataCopy, this.field, sanitization.rule.args, config);\n    });\n  }\n\n}\n\nexports.SanitizationsRunner = SanitizationsRunner;","map":{"version":3,"sources":["/opt/lampp/htdocs/react-blog/node_modules/indicative-compiler/build/src/Sanitizer/SanitizationsRunner.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","isobject_1","require","lodash_get_1","SanitizationsRunner","constructor","field","dotPath","rules","sanitizations","computeSanitizations","map","rule","sanitization","name","Error","sanitize","compile","args","fn","getDataCopy","data","tip","length","default","assign","exec","config","dataCopy","forEach"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @module compiler/sanitizer\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst isobject_1 = __importDefault(require(\"isobject\"));\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Runs an array of sanitizations on a given field.\n */\nclass SanitizationsRunner {\n    constructor(field, dotPath, rules, sanitizations) {\n        this.field = field;\n        this.dotPath = dotPath;\n        this.sanitizations = [];\n        this.computeSanitizations(sanitizations, rules);\n    }\n    /**\n     * Pull sanitizations for the list defined rules.\n     */\n    computeSanitizations(sanitizations, rules) {\n        this.sanitizations = rules.map((rule) => {\n            const sanitization = sanitizations[rule.name];\n            /**\n             * Raise exception when sanitization implementation for a\n             * given rule is missing.\n             */\n            if (!sanitization) {\n                throw new Error(`${rule.name} is not a registered as a sanitization`);\n            }\n            /**\n             * The sanitization node must have a `validate` function.\n             */\n            if (typeof (sanitization.sanitize) !== 'function') {\n                throw new Error(`${rule.name} is missing sanitize function`);\n            }\n            /**\n             * Mutate args when `compile` function is defined. It is a way to\n             * normalize arguments before the sanitization process kicks in.\n             */\n            if (typeof (sanitization.compile) === 'function') {\n                rule.args = sanitization.compile(rule.args);\n            }\n            return { rule: rule, fn: sanitization.sanitize };\n        });\n    }\n    /**\n     * Returns a fresh data copy by copying some of the values from the actual\n     * data and then mutating the `tip` and `pointer`. The tip and pointer\n     * are mutated so that the sanitization function receives the closest\n     * object from the pointer, resulting in performant code.\n     */\n    getDataCopy(data) {\n        const tip = this.dotPath.length ? lodash_get_1.default(data.tip, this.dotPath) : data.tip;\n        /**\n         * Updating the tip and pointer\n         */\n        return Object.assign({}, data, {\n            tip: this.field === '::tip::' ? { [this.field]: tip } : tip,\n        });\n    }\n    /**\n     * Execute all sanitization in series for a given filed\n     */\n    exec(data, config) {\n        const dataCopy = this.getDataCopy(data);\n        /**\n         * Skip validations when the parent value of this field is not\n         * an object. The user must validate the parent to be object\n         * seperately.\n         */\n        if (!isobject_1.default(dataCopy.tip)) {\n            return;\n        }\n        this.sanitizations.forEach((sanitization) => {\n            sanitization.fn(dataCopy, this.field, sanitization.rule.args, config);\n        });\n    }\n}\nexports.SanitizationsRunner = SanitizationsRunner;\n"]},"metadata":{},"sourceType":"script"}