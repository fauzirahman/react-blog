{"ast":null,"code":"\"use strict\";\n/**\n * @module compiler/validator\n */\n\nvar _regeneratorRuntime = require(\"/opt/lampp/htdocs/react-blog/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/opt/lampp/htdocs/react-blog/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _defineProperty = require(\"/opt/lampp/htdocs/react-blog/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/opt/lampp/htdocs/react-blog/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/lampp/htdocs/react-blog/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nvar isobject_1 = __importDefault(require(\"isobject\"));\n\nvar lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Runs a series of validations on a given field. This class is feeded with the\n * computed nodes generated via [[TreeWalker]].\n */\n\n\nvar ValidationsRunner =\n/*#__PURE__*/\nfunction () {\n  function ValidationsRunner(field, type, dotPath, rules, validations, fieldMessages, genericMessages) {\n    _classCallCheck(this, ValidationsRunner);\n\n    this.field = field;\n    this.type = type;\n    this.dotPath = dotPath;\n    this.fieldMessages = fieldMessages;\n    this.genericMessages = genericMessages;\n    /**\n     * We toggle this flag then creating the `validations` object\n     */\n\n    this.async = false;\n    /**\n     * Collection of validations to be executed on a given field.\n     */\n\n    this.validations = [];\n    /**\n     * Base pointer to this field. When field is inside an\n     * array, then we need to re-compute the pointer\n     * based upon the current index in which this\n     * field is validated.\n     *\n     * However, we don't mutate this field.\n     */\n\n    this.pointer = this.dotPath.concat(this.field).join('.');\n    this.computeValidations(validations, rules);\n  }\n  /**\n   * Creating a list of validation functions to be executed as per\n   * the defined rules.\n   */\n\n\n  _createClass(ValidationsRunner, [{\n    key: \"computeValidations\",\n    value: function computeValidations(validations, rules) {\n      var _this = this;\n\n      this.validations = rules.map(function (rule) {\n        var validation = validations[rule.name];\n        /**\n         * Raise exception when validation implementation for a\n         * given rule is missing.\n         */\n\n        if (!validation) {\n          throw new Error(\"\".concat(rule.name, \" is not a registered as a validation\"));\n        }\n        /**\n         * The validation node must have a `validate` function.\n         */\n\n\n        if (typeof validation.validate !== 'function') {\n          throw new Error(\"\".concat(rule.name, \" is missing validate function\"));\n        }\n        /**\n         * Mutate args when `compile` function is defined. It is a way to\n         * normalize arguments before the validation process kicks in.\n         */\n\n\n        if (typeof validation.compile === 'function') {\n          rule.args = validation.compile(rule.args);\n        }\n        /**\n         * Set the flag to `true` when one or more validations are `async`.\n         * This tells the consumer of [[ValidationsRunner]] class to make\n         * use of `execAsync` over `exec`. All done for performance.\n         */\n\n\n        if (validation.async) {\n          _this.async = true;\n        }\n\n        return {\n          rule: rule,\n          fn: validation.validate,\n          async: validation.async\n        };\n      });\n    }\n    /**\n     * Returns a fresh data copy by copying some of the values from the actual\n     * data and then mutating the `tip` and `pointer`. The tip and pointer\n     * are mutated so that the validation function receives the closest\n     * object from the pointer, resulting in performant code.\n     */\n\n  }, {\n    key: \"getDataCopy\",\n    value: function getDataCopy(data) {\n      var tip = this.dotPath.length ? lodash_get_1.default(data.tip, this.dotPath) : data.tip;\n      /**\n       * Prefix array pointer and current index, when this field is part\n       * of an array.\n       * Also do not append the pointer when pointer is `::tip::`\n       */\n\n      var pointer = data.arrayPointer ? this.pointer === '::tip::' ? \"\".concat(data.arrayPointer, \".\").concat(data.currentIndex) : \"\".concat(data.arrayPointer, \".\").concat(data.currentIndex, \".\").concat(this.pointer) : this.pointer;\n      /**\n       * Updating the tip and pointer\n       */\n\n      return Object.assign({}, data, {\n        tip: this.field === '::tip::' ? _defineProperty({}, this.field, tip) : tip,\n        pointer: pointer\n      });\n    }\n    /**\n     * Reports value to the collector when current field is a literal\n     * node inside the tree and validation has passed\n     */\n\n  }, {\n    key: \"reportValueToCollector\",\n    value: function reportValueToCollector(passed, data, collector) {\n      if (!passed || this.type !== 'literal') {\n        return;\n      }\n\n      collector.setValue(data.pointer, data.tip[this.field]);\n    }\n    /**\n     * Reports the validation error to the collector.\n     */\n\n  }, {\n    key: \"reportErrorToCollector\",\n    value: function reportErrorToCollector(pointer, rule, collector, exception) {\n      var message = exception || this.fieldMessages[rule.name] || this.genericMessages[rule.name];\n      collector.setError(pointer, rule, message);\n    }\n    /**\n     * Executes all the validations on a given field synchronously. Run\n     * [[ValidationsRunner.execAsync]] if want to execute asynchronously.\n     */\n\n  }, {\n    key: \"exec\",\n    value: function exec(data, collector, config) {\n      var bail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var dataCopy = this.getDataCopy(data);\n      /**\n       * Skip validations when the parent value of this field is not\n       * an object. The user must validate the parent to be object\n       * seperately.\n       */\n\n      if (!isobject_1.default(dataCopy.tip)) {\n        return true;\n      }\n\n      var hasFailures = false;\n      /**\n       * Sequentially loop over all the validations.\n       * We break the loop, when `bail=true`.\n       */\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.validations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var validation = _step.value;\n          var exception = null;\n          var passed = true;\n          /**\n           * Wrapping the validation function for unexpected errors.\n           */\n\n          try {\n            passed = validation.fn(dataCopy, this.field, validation.rule.args, config);\n          } catch (error) {\n            exception = error;\n            passed = false;\n          }\n\n          if (!passed) {\n            hasFailures = true;\n            this.reportErrorToCollector(dataCopy.pointer, validation.rule, collector, exception);\n\n            if (bail) {\n              break;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.reportValueToCollector(!hasFailures, dataCopy, collector);\n      return !hasFailures;\n    }\n    /**\n     * Executes all the validations on a given field asynchronously. Run\n     * [[ValidationsRunner.exec]] if want to execute synchronously.\n     */\n\n  }, {\n    key: \"execAsync\",\n    value: function () {\n      var _execAsync = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(data, collector, config) {\n        var bail,\n            dataCopy,\n            hasFailures,\n            _iteratorNormalCompletion2,\n            _didIteratorError2,\n            _iteratorError2,\n            _iterator2,\n            _step2,\n            validation,\n            exception,\n            passed,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                bail = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;\n                dataCopy = this.getDataCopy(data);\n                /**\n                 * Skip validations when the parent value of this field is not\n                 * an object. The user must validate the parent to be object\n                 * seperately.\n                 */\n\n                if (isobject_1.default(dataCopy.tip)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", true);\n\n              case 4:\n                hasFailures = false;\n                /**\n                 * Sequentially loop over all the validations.\n                 * We break the loop, when `bail=true`.\n                 */\n\n                _iteratorNormalCompletion2 = true;\n                _didIteratorError2 = false;\n                _iteratorError2 = undefined;\n                _context.prev = 8;\n                _iterator2 = this.validations[Symbol.iterator]();\n\n              case 10:\n                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                  _context.next = 36;\n                  break;\n                }\n\n                validation = _step2.value;\n                exception = null;\n                passed = true;\n                _context.prev = 14;\n\n                if (!validation.async) {\n                  _context.next = 21;\n                  break;\n                }\n\n                _context.next = 18;\n                return validation.fn(dataCopy, this.field, validation.rule.args, config);\n\n              case 18:\n                passed = _context.sent;\n                _context.next = 22;\n                break;\n\n              case 21:\n                passed = validation.fn(dataCopy, this.field, validation.rule.args, config);\n\n              case 22:\n                _context.next = 28;\n                break;\n\n              case 24:\n                _context.prev = 24;\n                _context.t0 = _context[\"catch\"](14);\n                passed = false;\n                exception = _context.t0;\n\n              case 28:\n                if (passed) {\n                  _context.next = 33;\n                  break;\n                }\n\n                hasFailures = true;\n                this.reportErrorToCollector(dataCopy.pointer, validation.rule, collector, exception);\n\n                if (!bail) {\n                  _context.next = 33;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 36);\n\n              case 33:\n                _iteratorNormalCompletion2 = true;\n                _context.next = 10;\n                break;\n\n              case 36:\n                _context.next = 42;\n                break;\n\n              case 38:\n                _context.prev = 38;\n                _context.t1 = _context[\"catch\"](8);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context.t1;\n\n              case 42:\n                _context.prev = 42;\n                _context.prev = 43;\n\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n\n              case 45:\n                _context.prev = 45;\n\n                if (!_didIteratorError2) {\n                  _context.next = 48;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 48:\n                return _context.finish(45);\n\n              case 49:\n                return _context.finish(42);\n\n              case 50:\n                this.reportValueToCollector(!hasFailures, dataCopy, collector);\n                return _context.abrupt(\"return\", !hasFailures);\n\n              case 52:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[8, 38, 42, 50], [14, 24], [43,, 45, 49]]);\n      }));\n\n      function execAsync(_x, _x2, _x3) {\n        return _execAsync.apply(this, arguments);\n      }\n\n      return execAsync;\n    }()\n  }]);\n\n  return ValidationsRunner;\n}();\n\nexports.ValidationsRunner = ValidationsRunner;","map":{"version":3,"sources":["/opt/lampp/htdocs/react-blog/node_modules/indicative-compiler/build/src/Validator/ValidationsRunner.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","isobject_1","require","lodash_get_1","ValidationsRunner","field","type","dotPath","rules","validations","fieldMessages","genericMessages","async","pointer","concat","join","computeValidations","map","rule","validation","name","Error","validate","compile","args","fn","data","tip","length","default","arrayPointer","currentIndex","assign","passed","collector","setValue","exception","message","setError","config","bail","dataCopy","getDataCopy","hasFailures","error","reportErrorToCollector","reportValueToCollector"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @module compiler/validator\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst isobject_1 = __importDefault(require(\"isobject\"));\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Runs a series of validations on a given field. This class is feeded with the\n * computed nodes generated via [[TreeWalker]].\n */\nclass ValidationsRunner {\n    constructor(field, type, dotPath, rules, validations, fieldMessages, genericMessages) {\n        this.field = field;\n        this.type = type;\n        this.dotPath = dotPath;\n        this.fieldMessages = fieldMessages;\n        this.genericMessages = genericMessages;\n        /**\n         * We toggle this flag then creating the `validations` object\n         */\n        this.async = false;\n        /**\n         * Collection of validations to be executed on a given field.\n         */\n        this.validations = [];\n        /**\n         * Base pointer to this field. When field is inside an\n         * array, then we need to re-compute the pointer\n         * based upon the current index in which this\n         * field is validated.\n         *\n         * However, we don't mutate this field.\n         */\n        this.pointer = this.dotPath.concat(this.field).join('.');\n        this.computeValidations(validations, rules);\n    }\n    /**\n     * Creating a list of validation functions to be executed as per\n     * the defined rules.\n     */\n    computeValidations(validations, rules) {\n        this.validations = rules.map((rule) => {\n            const validation = validations[rule.name];\n            /**\n             * Raise exception when validation implementation for a\n             * given rule is missing.\n             */\n            if (!validation) {\n                throw new Error(`${rule.name} is not a registered as a validation`);\n            }\n            /**\n             * The validation node must have a `validate` function.\n             */\n            if (typeof (validation.validate) !== 'function') {\n                throw new Error(`${rule.name} is missing validate function`);\n            }\n            /**\n             * Mutate args when `compile` function is defined. It is a way to\n             * normalize arguments before the validation process kicks in.\n             */\n            if (typeof (validation.compile) === 'function') {\n                rule.args = validation.compile(rule.args);\n            }\n            /**\n             * Set the flag to `true` when one or more validations are `async`.\n             * This tells the consumer of [[ValidationsRunner]] class to make\n             * use of `execAsync` over `exec`. All done for performance.\n             */\n            if (validation.async) {\n                this.async = true;\n            }\n            return { rule: rule, fn: validation.validate, async: validation.async };\n        });\n    }\n    /**\n     * Returns a fresh data copy by copying some of the values from the actual\n     * data and then mutating the `tip` and `pointer`. The tip and pointer\n     * are mutated so that the validation function receives the closest\n     * object from the pointer, resulting in performant code.\n     */\n    getDataCopy(data) {\n        const tip = this.dotPath.length ? lodash_get_1.default(data.tip, this.dotPath) : data.tip;\n        /**\n         * Prefix array pointer and current index, when this field is part\n         * of an array.\n         * Also do not append the pointer when pointer is `::tip::`\n         */\n        const pointer = data.arrayPointer ?\n            (this.pointer === '::tip::'\n                ? `${data.arrayPointer}.${data.currentIndex}`\n                : `${data.arrayPointer}.${data.currentIndex}.${this.pointer}`)\n            : this.pointer;\n        /**\n         * Updating the tip and pointer\n         */\n        return Object.assign({}, data, {\n            tip: this.field === '::tip::' ? { [this.field]: tip } : tip,\n            pointer: pointer,\n        });\n    }\n    /**\n     * Reports value to the collector when current field is a literal\n     * node inside the tree and validation has passed\n     */\n    reportValueToCollector(passed, data, collector) {\n        if (!passed || this.type !== 'literal') {\n            return;\n        }\n        collector.setValue(data.pointer, data.tip[this.field]);\n    }\n    /**\n     * Reports the validation error to the collector.\n     */\n    reportErrorToCollector(pointer, rule, collector, exception) {\n        const message = exception || this.fieldMessages[rule.name] || this.genericMessages[rule.name];\n        collector.setError(pointer, rule, message);\n    }\n    /**\n     * Executes all the validations on a given field synchronously. Run\n     * [[ValidationsRunner.execAsync]] if want to execute asynchronously.\n     */\n    exec(data, collector, config, bail = false) {\n        const dataCopy = this.getDataCopy(data);\n        /**\n         * Skip validations when the parent value of this field is not\n         * an object. The user must validate the parent to be object\n         * seperately.\n         */\n        if (!isobject_1.default(dataCopy.tip)) {\n            return true;\n        }\n        let hasFailures = false;\n        /**\n         * Sequentially loop over all the validations.\n         * We break the loop, when `bail=true`.\n         */\n        for (let validation of this.validations) {\n            let exception = null;\n            let passed = true;\n            /**\n             * Wrapping the validation function for unexpected errors.\n             */\n            try {\n                passed = validation.fn(dataCopy, this.field, validation.rule.args, config);\n            }\n            catch (error) {\n                exception = error;\n                passed = false;\n            }\n            if (!passed) {\n                hasFailures = true;\n                this.reportErrorToCollector(dataCopy.pointer, validation.rule, collector, exception);\n                if (bail) {\n                    break;\n                }\n            }\n        }\n        this.reportValueToCollector(!hasFailures, dataCopy, collector);\n        return !hasFailures;\n    }\n    /**\n     * Executes all the validations on a given field asynchronously. Run\n     * [[ValidationsRunner.exec]] if want to execute synchronously.\n     */\n    async execAsync(data, collector, config, bail = false) {\n        const dataCopy = this.getDataCopy(data);\n        /**\n         * Skip validations when the parent value of this field is not\n         * an object. The user must validate the parent to be object\n         * seperately.\n         */\n        if (!isobject_1.default(dataCopy.tip)) {\n            return true;\n        }\n        let hasFailures = false;\n        /**\n         * Sequentially loop over all the validations.\n         * We break the loop, when `bail=true`.\n         */\n        for (let validation of this.validations) {\n            let exception = null;\n            let passed = true;\n            try {\n                if (validation.async) {\n                    passed = await validation.fn(dataCopy, this.field, validation.rule.args, config);\n                }\n                else {\n                    passed = validation.fn(dataCopy, this.field, validation.rule.args, config);\n                }\n            }\n            catch (error) {\n                passed = false;\n                exception = error;\n            }\n            if (!passed) {\n                hasFailures = true;\n                this.reportErrorToCollector(dataCopy.pointer, validation.rule, collector, exception);\n                if (bail) {\n                    break;\n                }\n            }\n        }\n        this.reportValueToCollector(!hasFailures, dataCopy, collector);\n        return !hasFailures;\n    }\n}\nexports.ValidationsRunner = ValidationsRunner;\n"]},"metadata":{},"sourceType":"script"}