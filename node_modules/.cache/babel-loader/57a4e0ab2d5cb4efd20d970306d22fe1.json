{"ast":null,"code":"\"use strict\";\n/*\n* indicative-parser\n*\n* (c) Harminder Virk <virk@adonisjs.com>\n*\n* For the full copyright and license information, please view the LICENSE\n* file that was distributed with this source code.\n*/\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst haye_pipe_1 = __importDefault(require(\"haye/dist/haye-pipe\"));\n\nconst haye_array_presenter_1 = __importDefault(require(\"haye/dist/haye-array-presenter\"));\n\nfunction toCamelCase(ruleName) {\n  return ruleName.replace(/_(\\w)/g, (_match, group) => group.toUpperCase());\n}\n/**\n * Updates rules on the given node. If node is missing, then a literal node is\n * created automatically. Literal nodes can later transform into `object` and\n * `array` nodes.\n */\n\n\nfunction setLiteral(source, key, rules) {\n  const item = source[key] || {\n    type: 'literal'\n  };\n  item.rules = rules;\n  source[key] = item;\n  return item;\n}\n/**\n * Creates/updates literal node to an object node. Since `object` node\n * properties are different from `literal` node, we need to set those\n * properties (if missing).\n *\n * If node already exists and is an array node, then this method will raise an\n * exception\n */\n\n\nfunction setObject(source, key) {\n  if (source[key] && source[key].type === 'array') {\n    throw new Error(`cannot reshape ${key} array to an object`);\n  }\n\n  const item = source[key] || {\n    rules: []\n  };\n  item.type = 'object';\n  item.children = item.children || {};\n  source[key] = item;\n  return item;\n}\n/**\n * Creates/updates literal node to an array node. Since `array` node\n * properties are different from `literal` node, we need to set those\n * properties (if missing).\n *\n * If node already exists and is an object node, then this method will raise an\n * exception\n */\n\n\nfunction setArray(source, key, index) {\n  if (source[key] && source[key].type === 'object') {\n    throw new Error(`cannot reshape ${key} object to an array`);\n  }\n\n  const item = source[key] || {\n    rules: []\n  };\n  item.each = item.each || {};\n  item.each[index] = item.each[index] || {\n    children: {},\n    rules: []\n  };\n  item.type = 'array';\n  source[key] = item;\n  return item;\n}\n/**\n * Parses field tokens recursively to a [[ParsedSchema]] tree\n */\n\n\nfunction parseFieldForRules(tokens, rules, out, index = 0) {\n  const token = tokens[index++];\n  /**\n   * Finding if we are on the last item. Last item defines\n   * the rules for the current node inside the tree\n   */\n\n  const isLast = tokens.length === index;\n  /**\n   * Indexed array have `digits` like `users.0.username`\n   */\n\n  const isIndexedArray = /^\\d+$/.test(tokens[index]);\n  /**\n   * Is upcoming token an array\n   */\n\n  const isArray = tokens[index] === '*' || isIndexedArray;\n  /**\n   * Last item was marked as array, since current token is a `*`\n   * or has defined index\n   */\n\n  if (token === '*' || /^\\d+$/.test(token)) {\n    /**\n     * Last item must update rules for each item for the array\n     */\n    if (isLast) {\n      out.each[token].rules = rules;\n      return;\n    }\n    /**\n     * Nested arrays\n     */\n\n\n    if (isArray) {\n      /**\n       * The code after the error works fine. However, in order to support\n       * 2d arrays, we need to implement them inside the declarative\n       * schema and compiler as well.\n       *\n       * For now, it's okay to skip this feature and later work on it\n       * across all the modules.\n       */\n      throw new Error('2d arrays are currently not supported'); // const item = setArray(\n      //   (out as SchemaNodeArray).each[token].children,\n      //   token,\n      //   isIndexedArray ? tokens[index] : '*',\n      // )\n      // return parseFieldForRules(tokens, rules, item, index)\n    }\n    /**\n     * Otherwise continue recursion\n     */\n\n\n    return parseFieldForRules(tokens, rules, out.each[token].children, index);\n  }\n  /**\n   * Last item in the list of tokens. we must\n   * patch the rules here.\n   */\n\n\n  if (isLast) {\n    setLiteral(out, token, rules);\n    return;\n  }\n  /**\n   * Current item as an array\n   */\n\n\n  if (isArray) {\n    const item = setArray(out, token, isIndexedArray ? tokens[index] : '*');\n    return parseFieldForRules(tokens, rules, item, index);\n  }\n  /**\n   * Falling back to object\n   */\n\n\n  const item = setObject(out, token);\n  return parseFieldForRules(tokens, rules, item.children, index);\n}\n/**\n * Parses the schema object to a tree of parsed schema. The\n * output is optimized for executing validation rules.\n *\n * @example\n * ```\n * parser({\n *  'users.*.username': 'required'\n * })\n *\n * // output\n *\n * {\n *   users: {\n *    type: 'array',\n *    rules: [],\n *    each: {\n *      '*': {\n *        rules: [],\n *        children: {\n *          username: {\n *            type: 'literal',\n *            rules: [{\n *              name: 'required',\n *              args: []\n *            }]\n *          }\n *        }\n *      }\n *    }\n *   }\n * }\n * ```\n */\n\n\nfunction rulesParser(schema) {\n  if (schema.schema) {\n    return schema.schema;\n  }\n\n  return Object.keys(schema).reduce((result, field) => {\n    const rules = schema[field];\n    let parsedRules = [];\n\n    if (!rules) {\n      throw new Error(`make sure to define rules for ${field}`);\n    }\n\n    if (typeof rules === 'string') {\n      parsedRules = new haye_pipe_1.default(rules, new haye_array_presenter_1.default()).map(rule => {\n        return {\n          name: toCamelCase(rule.name),\n          args: rule.args\n        };\n      });\n    } else {\n      parsedRules = rules;\n    }\n\n    parseFieldForRules(field.split('.'), parsedRules, result);\n    return result;\n  }, {});\n}\n\nexports.rulesParser = rulesParser;\n/**\n * Parses an object of messages to [[ParsedMessages]] list. The messages list\n * is simpler than rules tree, since compiler can use the schema tree to find\n * the appropriate messages from the flat list of messages.\n *\n * @example\n * ```\n * parser({\n *  'users.*.username.required': 'Username is required'\n * })\n *\n * // output\n *\n * {\n *   fields: {\n *    'users.*.username': {\n *      required: 'Username is required'\n *    }\n *   },\n *   rules: {},\n * }\n */\n\nfunction messagesParser(schema) {\n  return Object.keys(schema).reduce((result, field) => {\n    const message = schema[field];\n    const tokens = field.split('.');\n    const rule = toCamelCase(tokens.pop());\n    /**\n     * If token length is 1, then it is a plain rule vs `field.rule`\n     */\n\n    if (!tokens.length) {\n      result.rules[rule] = message;\n      return result;\n    }\n\n    const qualifiedName = tokens.join('.');\n    result.fields[qualifiedName] = result.fields[qualifiedName] || {};\n    result.fields[qualifiedName][rule] = message;\n    return result;\n  }, {\n    fields: {},\n    rules: {}\n  });\n}\n\nexports.messagesParser = messagesParser;","map":{"version":3,"sources":["/opt/lampp/htdocs/blog-app/node_modules/indicative-parser/build/src/main.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","haye_pipe_1","require","haye_array_presenter_1","toCamelCase","ruleName","replace","_match","group","toUpperCase","setLiteral","source","key","rules","item","type","setObject","Error","children","setArray","index","each","parseFieldForRules","tokens","out","token","isLast","length","isIndexedArray","test","isArray","rulesParser","schema","keys","reduce","result","field","parsedRules","default","map","rule","name","args","split","messagesParser","message","pop","qualifiedName","join","fields"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\n* indicative-parser\n*\n* (c) Harminder Virk <virk@adonisjs.com>\n*\n* For the full copyright and license information, please view the LICENSE\n* file that was distributed with this source code.\n*/\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst haye_pipe_1 = __importDefault(require(\"haye/dist/haye-pipe\"));\nconst haye_array_presenter_1 = __importDefault(require(\"haye/dist/haye-array-presenter\"));\nfunction toCamelCase(ruleName) {\n    return ruleName.replace(/_(\\w)/g, (_match, group) => group.toUpperCase());\n}\n/**\n * Updates rules on the given node. If node is missing, then a literal node is\n * created automatically. Literal nodes can later transform into `object` and\n * `array` nodes.\n */\nfunction setLiteral(source, key, rules) {\n    const item = (source[key] || { type: 'literal' });\n    item.rules = rules;\n    source[key] = item;\n    return item;\n}\n/**\n * Creates/updates literal node to an object node. Since `object` node\n * properties are different from `literal` node, we need to set those\n * properties (if missing).\n *\n * If node already exists and is an array node, then this method will raise an\n * exception\n */\nfunction setObject(source, key) {\n    if (source[key] && source[key].type === 'array') {\n        throw new Error(`cannot reshape ${key} array to an object`);\n    }\n    const item = (source[key] || { rules: [] });\n    item.type = 'object';\n    item.children = item.children || {};\n    source[key] = item;\n    return item;\n}\n/**\n * Creates/updates literal node to an array node. Since `array` node\n * properties are different from `literal` node, we need to set those\n * properties (if missing).\n *\n * If node already exists and is an object node, then this method will raise an\n * exception\n */\nfunction setArray(source, key, index) {\n    if (source[key] && source[key].type === 'object') {\n        throw new Error(`cannot reshape ${key} object to an array`);\n    }\n    const item = (source[key] || { rules: [] });\n    item.each = item.each || {};\n    item.each[index] = item.each[index] || { children: {}, rules: [] };\n    item.type = 'array';\n    source[key] = item;\n    return item;\n}\n/**\n * Parses field tokens recursively to a [[ParsedSchema]] tree\n */\nfunction parseFieldForRules(tokens, rules, out, index = 0) {\n    const token = tokens[index++];\n    /**\n     * Finding if we are on the last item. Last item defines\n     * the rules for the current node inside the tree\n     */\n    const isLast = tokens.length === index;\n    /**\n     * Indexed array have `digits` like `users.0.username`\n     */\n    const isIndexedArray = /^\\d+$/.test(tokens[index]);\n    /**\n     * Is upcoming token an array\n     */\n    const isArray = tokens[index] === '*' || isIndexedArray;\n    /**\n     * Last item was marked as array, since current token is a `*`\n     * or has defined index\n     */\n    if (token === '*' || /^\\d+$/.test(token)) {\n        /**\n         * Last item must update rules for each item for the array\n         */\n        if (isLast) {\n            out.each[token].rules = rules;\n            return;\n        }\n        /**\n         * Nested arrays\n         */\n        if (isArray) {\n            /**\n             * The code after the error works fine. However, in order to support\n             * 2d arrays, we need to implement them inside the declarative\n             * schema and compiler as well.\n             *\n             * For now, it's okay to skip this feature and later work on it\n             * across all the modules.\n             */\n            throw new Error('2d arrays are currently not supported');\n            // const item = setArray(\n            //   (out as SchemaNodeArray).each[token].children,\n            //   token,\n            //   isIndexedArray ? tokens[index] : '*',\n            // )\n            // return parseFieldForRules(tokens, rules, item, index)\n        }\n        /**\n         * Otherwise continue recursion\n         */\n        return parseFieldForRules(tokens, rules, out.each[token].children, index);\n    }\n    /**\n     * Last item in the list of tokens. we must\n     * patch the rules here.\n     */\n    if (isLast) {\n        setLiteral(out, token, rules);\n        return;\n    }\n    /**\n     * Current item as an array\n     */\n    if (isArray) {\n        const item = setArray(out, token, isIndexedArray ? tokens[index] : '*');\n        return parseFieldForRules(tokens, rules, item, index);\n    }\n    /**\n     * Falling back to object\n     */\n    const item = setObject(out, token);\n    return parseFieldForRules(tokens, rules, item.children, index);\n}\n/**\n * Parses the schema object to a tree of parsed schema. The\n * output is optimized for executing validation rules.\n *\n * @example\n * ```\n * parser({\n *  'users.*.username': 'required'\n * })\n *\n * // output\n *\n * {\n *   users: {\n *    type: 'array',\n *    rules: [],\n *    each: {\n *      '*': {\n *        rules: [],\n *        children: {\n *          username: {\n *            type: 'literal',\n *            rules: [{\n *              name: 'required',\n *              args: []\n *            }]\n *          }\n *        }\n *      }\n *    }\n *   }\n * }\n * ```\n */\nfunction rulesParser(schema) {\n    if (schema.schema) {\n        return schema.schema;\n    }\n    return Object\n        .keys(schema)\n        .reduce((result, field) => {\n        const rules = schema[field];\n        let parsedRules = [];\n        if (!rules) {\n            throw new Error(`make sure to define rules for ${field}`);\n        }\n        if (typeof (rules) === 'string') {\n            parsedRules = new haye_pipe_1.default(rules, new haye_array_presenter_1.default()).map((rule) => {\n                return { name: toCamelCase(rule.name), args: rule.args };\n            });\n        }\n        else {\n            parsedRules = rules;\n        }\n        parseFieldForRules(field.split('.'), parsedRules, result);\n        return result;\n    }, {});\n}\nexports.rulesParser = rulesParser;\n/**\n * Parses an object of messages to [[ParsedMessages]] list. The messages list\n * is simpler than rules tree, since compiler can use the schema tree to find\n * the appropriate messages from the flat list of messages.\n *\n * @example\n * ```\n * parser({\n *  'users.*.username.required': 'Username is required'\n * })\n *\n * // output\n *\n * {\n *   fields: {\n *    'users.*.username': {\n *      required: 'Username is required'\n *    }\n *   },\n *   rules: {},\n * }\n */\nfunction messagesParser(schema) {\n    return Object\n        .keys(schema)\n        .reduce((result, field) => {\n        const message = schema[field];\n        const tokens = field.split('.');\n        const rule = toCamelCase(tokens.pop());\n        /**\n         * If token length is 1, then it is a plain rule vs `field.rule`\n         */\n        if (!tokens.length) {\n            result.rules[rule] = message;\n            return result;\n        }\n        const qualifiedName = tokens.join('.');\n        result.fields[qualifiedName] = result.fields[qualifiedName] || {};\n        result.fields[qualifiedName][rule] = message;\n        return result;\n    }, { fields: {}, rules: {} });\n}\nexports.messagesParser = messagesParser;\n"]},"metadata":{},"sourceType":"script"}