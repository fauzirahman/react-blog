{"ast":null,"code":"\"use strict\";\n/**\n * @module indicative\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n* indicative\n*\n* (c) Harminder Virk <virk@adonisjs.com>\n*\n* For the full copyright and license information, please view the LICENSE\n* file that was distributed with this source code.\n*/\n\nvar indicative_rules_1 = require(\"indicative-rules\");\n\nvar indicative_compiler_1 = require(\"indicative-compiler\");\n\nvar CacheManager_1 = require(\"../CacheManager\");\n\nvar config_1 = require(\"./config\");\n\nvar cacheManager = new CacheManager_1.CacheManager();\n/**\n * Returns executor by pre-compiling and optionally caching schema.\n */\n\nfunction getExecutor(schema, messages, config) {\n  /**\n   * Always compile schema, when there is no cacheKey\n   */\n  if (!config.cacheKey) {\n    var compiler = new indicative_compiler_1.ValidatorCompiler(schema, messages, indicative_rules_1.validations);\n    return new indicative_compiler_1.ValidatorExecutor(compiler.compile());\n  }\n  /**\n   * Pre-compile the schema and set it as cache when it's not\n   * inside the cache already\n   */\n\n\n  var compiledSchema = cacheManager.get(config.cacheKey);\n\n  if (!compiledSchema) {\n    var _compiler = new indicative_compiler_1.ValidatorCompiler(schema, messages, indicative_rules_1.validations);\n\n    cacheManager.set(config.cacheKey, _compiler.compile());\n  }\n\n  return new indicative_compiler_1.ValidatorExecutor(cacheManager.get(config.cacheKey));\n}\n/**\n * Validates the given data set against the defined schema. The validator\n * stops at the first error. You must use [[validateAll]] to continue\n * validations, even after first error.\n *\n * It is recommended to define the `config` cacheKey to avoid\n * re-compiling the same schema again and again.\n */\n\n\nexports.validate = function (data, schema, messages, config) {\n  config = Object.assign({}, config_1.config, config);\n  return getExecutor(schema, messages || {}, config).exec(data, config.formatter, config, true, config.removeAdditional, config.customErrorCollector);\n};\n/**\n * Validates the given data set against the defined schema. The validator\n * continues even after errors. You must use [[validate]] to stop\n * validations after first error.\n *\n * It is recommended to define the `config` cacheKey to avoid\n * re-compiling the same schema again and again.\n */\n\n\nexports.validateAll = function (data, schema, messages, config) {\n  config = Object.assign({}, config_1.config, config);\n  return getExecutor(schema, messages || {}, config).exec(data, config.formatter, config, false, config.removeAdditional, config.customErrorCollector);\n};","map":{"version":3,"sources":["/opt/lampp/htdocs/react-blog/node_modules/indicative/src/Validator/index.js"],"names":["Object","defineProperty","exports","value","indicative_rules_1","require","indicative_compiler_1","CacheManager_1","config_1","cacheManager","CacheManager","getExecutor","schema","messages","config","cacheKey","compiler","ValidatorCompiler","validations","ValidatorExecutor","compile","compiledSchema","get","set","validate","data","assign","exec","formatter","removeAdditional","customErrorCollector","validateAll"],"mappings":"AAAA;AACA;;;;AAGAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA;;;;;;;;;AAQA,IAAMC,kBAAkB,GAAGC,OAAO,CAAC,kBAAD,CAAlC;;AACA,IAAMC,qBAAqB,GAAGD,OAAO,CAAC,qBAAD,CAArC;;AACA,IAAME,cAAc,GAAGF,OAAO,CAAC,iBAAD,CAA9B;;AACA,IAAMG,QAAQ,GAAGH,OAAO,CAAC,UAAD,CAAxB;;AACA,IAAMI,YAAY,GAAG,IAAIF,cAAc,CAACG,YAAnB,EAArB;AACA;;;;AAGA,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,QAA7B,EAAuCC,MAAvC,EAA+C;AAC3C;;;AAGA,MAAI,CAACA,MAAM,CAACC,QAAZ,EAAsB;AAClB,QAAMC,QAAQ,GAAG,IAAIV,qBAAqB,CAACW,iBAA1B,CAA4CL,MAA5C,EAAoDC,QAApD,EAA8DT,kBAAkB,CAACc,WAAjF,CAAjB;AACA,WAAO,IAAIZ,qBAAqB,CAACa,iBAA1B,CAA4CH,QAAQ,CAACI,OAAT,EAA5C,CAAP;AACH;AACD;;;;;;AAIA,MAAMC,cAAc,GAAGZ,YAAY,CAACa,GAAb,CAAiBR,MAAM,CAACC,QAAxB,CAAvB;;AACA,MAAI,CAACM,cAAL,EAAqB;AACjB,QAAML,SAAQ,GAAG,IAAIV,qBAAqB,CAACW,iBAA1B,CAA4CL,MAA5C,EAAoDC,QAApD,EAA8DT,kBAAkB,CAACc,WAAjF,CAAjB;;AACAT,IAAAA,YAAY,CAACc,GAAb,CAAiBT,MAAM,CAACC,QAAxB,EAAkCC,SAAQ,CAACI,OAAT,EAAlC;AACH;;AACD,SAAO,IAAId,qBAAqB,CAACa,iBAA1B,CAA4CV,YAAY,CAACa,GAAb,CAAiBR,MAAM,CAACC,QAAxB,CAA5C,CAAP;AACH;AACD;;;;;;;;;;AAQAb,OAAO,CAACsB,QAAR,GAAmB,UAACC,IAAD,EAAOb,MAAP,EAAeC,QAAf,EAAyBC,MAAzB,EAAoC;AACnDA,EAAAA,MAAM,GAAGd,MAAM,CAAC0B,MAAP,CAAc,EAAd,EAAkBlB,QAAQ,CAACM,MAA3B,EAAmCA,MAAnC,CAAT;AACA,SAAOH,WAAW,CAACC,MAAD,EAASC,QAAQ,IAAI,EAArB,EAAyBC,MAAzB,CAAX,CAA4Ca,IAA5C,CAAiDF,IAAjD,EAAuDX,MAAM,CAACc,SAA9D,EAAyEd,MAAzE,EAAiF,IAAjF,EAAuFA,MAAM,CAACe,gBAA9F,EAAgHf,MAAM,CAACgB,oBAAvH,CAAP;AACH,CAHD;AAIA;;;;;;;;;;AAQA5B,OAAO,CAAC6B,WAAR,GAAsB,UAACN,IAAD,EAAOb,MAAP,EAAeC,QAAf,EAAyBC,MAAzB,EAAoC;AACtDA,EAAAA,MAAM,GAAGd,MAAM,CAAC0B,MAAP,CAAc,EAAd,EAAkBlB,QAAQ,CAACM,MAA3B,EAAmCA,MAAnC,CAAT;AACA,SAAOH,WAAW,CAACC,MAAD,EAASC,QAAQ,IAAI,EAArB,EAAyBC,MAAzB,CAAX,CAA4Ca,IAA5C,CAAiDF,IAAjD,EAAuDX,MAAM,CAACc,SAA9D,EAAyEd,MAAzE,EAAiF,KAAjF,EAAwFA,MAAM,CAACe,gBAA/F,EAAiHf,MAAM,CAACgB,oBAAxH,CAAP;AACH,CAHD","sourcesContent":["\"use strict\";\n/**\n * @module indicative\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n* indicative\n*\n* (c) Harminder Virk <virk@adonisjs.com>\n*\n* For the full copyright and license information, please view the LICENSE\n* file that was distributed with this source code.\n*/\nconst indicative_rules_1 = require(\"indicative-rules\");\nconst indicative_compiler_1 = require(\"indicative-compiler\");\nconst CacheManager_1 = require(\"../CacheManager\");\nconst config_1 = require(\"./config\");\nconst cacheManager = new CacheManager_1.CacheManager();\n/**\n * Returns executor by pre-compiling and optionally caching schema.\n */\nfunction getExecutor(schema, messages, config) {\n    /**\n     * Always compile schema, when there is no cacheKey\n     */\n    if (!config.cacheKey) {\n        const compiler = new indicative_compiler_1.ValidatorCompiler(schema, messages, indicative_rules_1.validations);\n        return new indicative_compiler_1.ValidatorExecutor(compiler.compile());\n    }\n    /**\n     * Pre-compile the schema and set it as cache when it's not\n     * inside the cache already\n     */\n    const compiledSchema = cacheManager.get(config.cacheKey);\n    if (!compiledSchema) {\n        const compiler = new indicative_compiler_1.ValidatorCompiler(schema, messages, indicative_rules_1.validations);\n        cacheManager.set(config.cacheKey, compiler.compile());\n    }\n    return new indicative_compiler_1.ValidatorExecutor(cacheManager.get(config.cacheKey));\n}\n/**\n * Validates the given data set against the defined schema. The validator\n * stops at the first error. You must use [[validateAll]] to continue\n * validations, even after first error.\n *\n * It is recommended to define the `config` cacheKey to avoid\n * re-compiling the same schema again and again.\n */\nexports.validate = (data, schema, messages, config) => {\n    config = Object.assign({}, config_1.config, config);\n    return getExecutor(schema, messages || {}, config).exec(data, config.formatter, config, true, config.removeAdditional, config.customErrorCollector);\n};\n/**\n * Validates the given data set against the defined schema. The validator\n * continues even after errors. You must use [[validate]] to stop\n * validations after first error.\n *\n * It is recommended to define the `config` cacheKey to avoid\n * re-compiling the same schema again and again.\n */\nexports.validateAll = (data, schema, messages, config) => {\n    config = Object.assign({}, config_1.config, config);\n    return getExecutor(schema, messages || {}, config).exec(data, config.formatter, config, false, config.removeAdditional, config.customErrorCollector);\n};\n"]},"metadata":{},"sourceType":"script"}