{"ast":null,"code":"\"use strict\";\n/**\n * @module indicative\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst indicative_rules_1 = require(\"indicative-rules\");\n\nconst indicative_compiler_1 = require(\"indicative-compiler\");\n\nconst CacheManager_1 = require(\"../CacheManager\");\n\nconst cacheManager = new CacheManager_1.CacheManager();\n/**\n * Returns executor by pre-compiling and optionally caching schema.\n */\n\nfunction getExecutor(schema, config) {\n  /**\n   * Always compile schema, when there is no cacheKey\n   */\n  if (!config.cacheKey) {\n    const compiler = new indicative_compiler_1.SanitizerCompiler(schema, indicative_rules_1.sanitizations);\n    return new indicative_compiler_1.SanitizerExecutor(compiler.compile());\n  }\n  /**\n   * Pre-compile the schema and set it as cache when it's not\n   * inside the cache already\n   */\n\n\n  const compiledSchema = cacheManager.get(config.cacheKey);\n\n  if (!compiledSchema) {\n    const compiler = new indicative_compiler_1.SanitizerCompiler(schema, indicative_rules_1.sanitizations);\n    cacheManager.set(config.cacheKey, compiler.compile());\n  }\n\n  return new indicative_compiler_1.SanitizerExecutor(cacheManager.get(config.cacheKey));\n}\n/**\n * Santize given data against a pre-defined set of rules schema.\n *\n * It is recommended to define the `config` cacheKey to avoid\n * re-compiling the same schema again and again.\n */\n\n\nexports.sanitize = (data, schema, config) => {\n  config = config || {};\n  return getExecutor(schema, config).exec(data, config);\n};","map":{"version":3,"sources":["/opt/lampp/htdocs/react-blog/node_modules/indicative/src/Sanitizer/index.js"],"names":["Object","defineProperty","exports","value","indicative_rules_1","require","indicative_compiler_1","CacheManager_1","cacheManager","CacheManager","getExecutor","schema","config","cacheKey","compiler","SanitizerCompiler","sanitizations","SanitizerExecutor","compile","compiledSchema","get","set","sanitize","data","exec"],"mappings":"AAAA;AACA;;;;AAGAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,kBAAkB,GAAGC,OAAO,CAAC,kBAAD,CAAlC;;AACA,MAAMC,qBAAqB,GAAGD,OAAO,CAAC,qBAAD,CAArC;;AACA,MAAME,cAAc,GAAGF,OAAO,CAAC,iBAAD,CAA9B;;AACA,MAAMG,YAAY,GAAG,IAAID,cAAc,CAACE,YAAnB,EAArB;AACA;;;;AAGA,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,MAA7B,EAAqC;AACjC;;;AAGA,MAAI,CAACA,MAAM,CAACC,QAAZ,EAAsB;AAClB,UAAMC,QAAQ,GAAG,IAAIR,qBAAqB,CAACS,iBAA1B,CAA4CJ,MAA5C,EAAoDP,kBAAkB,CAACY,aAAvE,CAAjB;AACA,WAAO,IAAIV,qBAAqB,CAACW,iBAA1B,CAA4CH,QAAQ,CAACI,OAAT,EAA5C,CAAP;AACH;AACD;;;;;;AAIA,QAAMC,cAAc,GAAGX,YAAY,CAACY,GAAb,CAAiBR,MAAM,CAACC,QAAxB,CAAvB;;AACA,MAAI,CAACM,cAAL,EAAqB;AACjB,UAAML,QAAQ,GAAG,IAAIR,qBAAqB,CAACS,iBAA1B,CAA4CJ,MAA5C,EAAoDP,kBAAkB,CAACY,aAAvE,CAAjB;AACAR,IAAAA,YAAY,CAACa,GAAb,CAAiBT,MAAM,CAACC,QAAxB,EAAkCC,QAAQ,CAACI,OAAT,EAAlC;AACH;;AACD,SAAO,IAAIZ,qBAAqB,CAACW,iBAA1B,CAA4CT,YAAY,CAACY,GAAb,CAAiBR,MAAM,CAACC,QAAxB,CAA5C,CAAP;AACH;AACD;;;;;;;;AAMAX,OAAO,CAACoB,QAAR,GAAmB,CAACC,IAAD,EAAOZ,MAAP,EAAeC,MAAf,KAA0B;AACzCA,EAAAA,MAAM,GAAGA,MAAM,IAAI,EAAnB;AACA,SAAOF,WAAW,CAACC,MAAD,EAASC,MAAT,CAAX,CAA4BY,IAA5B,CAAiCD,IAAjC,EAAuCX,MAAvC,CAAP;AACH,CAHD","sourcesContent":["\"use strict\";\n/**\n * @module indicative\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst indicative_rules_1 = require(\"indicative-rules\");\nconst indicative_compiler_1 = require(\"indicative-compiler\");\nconst CacheManager_1 = require(\"../CacheManager\");\nconst cacheManager = new CacheManager_1.CacheManager();\n/**\n * Returns executor by pre-compiling and optionally caching schema.\n */\nfunction getExecutor(schema, config) {\n    /**\n     * Always compile schema, when there is no cacheKey\n     */\n    if (!config.cacheKey) {\n        const compiler = new indicative_compiler_1.SanitizerCompiler(schema, indicative_rules_1.sanitizations);\n        return new indicative_compiler_1.SanitizerExecutor(compiler.compile());\n    }\n    /**\n     * Pre-compile the schema and set it as cache when it's not\n     * inside the cache already\n     */\n    const compiledSchema = cacheManager.get(config.cacheKey);\n    if (!compiledSchema) {\n        const compiler = new indicative_compiler_1.SanitizerCompiler(schema, indicative_rules_1.sanitizations);\n        cacheManager.set(config.cacheKey, compiler.compile());\n    }\n    return new indicative_compiler_1.SanitizerExecutor(cacheManager.get(config.cacheKey));\n}\n/**\n * Santize given data against a pre-defined set of rules schema.\n *\n * It is recommended to define the `config` cacheKey to avoid\n * re-compiling the same schema again and again.\n */\nexports.sanitize = (data, schema, config) => {\n    config = config || {};\n    return getExecutor(schema, config).exec(data, config);\n};\n"]},"metadata":{},"sourceType":"script"}