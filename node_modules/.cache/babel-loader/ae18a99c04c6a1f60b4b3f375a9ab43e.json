{"ast":null,"code":"\"use strict\";\n/**\n * @module compiler/main\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Tree walker is an agnostic implementation to walk over the parsed schema\n * tree generated by `indicative-parser`.\n *\n * The consumer of the code can define a function to consumer the tree nodes and\n * define another function to wrap the children of an array node.\n *\n * ## Why wrap array children?\n * Since the length of an array is unknown, until we receive the data at\n * runtime, we need a parent function (aka wrapper), that can execute\n * the child validations as per the length of the array.\n *\n * ```js\n * function consumerFn (\n *   field: string,\n *   rules: ParsedRule[],\n *   dotPath: string[],\n *   pointer: string,\n * ) {\n * }\n *\n * function arrayWrapper (\n *   index: string,\n *   field: string,\n *   children: ReturnType<consumerFn>[],\n *   dotPath: string[],\n * ) {\n * }\n *\n * new TreeWalker(consumerFn, arrayWrapper).walk(parsedSchema)\n * ```\n */\n\nclass TreeWalker {\n  constructor(consumerFn, arrayWrapper) {\n    this.consumerFn = consumerFn;\n    this.arrayWrapper = arrayWrapper;\n  }\n  /**\n   * Processes the literal node inside schema tree\n   */\n\n\n  processLiteralNode(field, node, dotPath, arrayPath) {\n    const pointer = arrayPath.concat(dotPath).concat(field).join('.');\n    return this.consumerFn(field, node.type, node.rules, dotPath, pointer);\n  }\n  /**\n   * Process the object node inside the parsed. All children are parsed\n   * recursively\n   */\n\n\n  processObjectNode(field, node, dotPath, arrayPath) {\n    let output = [];\n    /**\n     * If object itself has rules, then we need to consume that\n     * as well.\n     */\n\n    if (node.rules.length) {\n      const pointer = arrayPath.concat(dotPath).concat(field).join('.');\n      output.push(this.consumerFn(field, node.type, node.rules, dotPath, pointer));\n    }\n    /**\n     * Walker over object children\n     */\n\n\n    output = output.concat(this.walk(node.children, dotPath.concat(field), arrayPath));\n    return output;\n  }\n  /**\n   * Process the array node of the schema tree. This method will call\n   * the `arrayWrapper` function and passes all array children to it.\n   */\n\n\n  processArrayNode(field, node, dotPath, arrayPath) {\n    let output = [];\n    const basePath = arrayPath.concat(dotPath).concat(field);\n    /**\n     * If array itself has rules, then we need to process that\n     * as well\n     */\n\n    if (node.rules.length) {\n      const pointer = basePath.join('.');\n      output.push(this.consumerFn(field, node.type, node.rules, dotPath, pointer));\n    }\n    /**\n     * Processing children for each index. The index of the tree can be a\n     * wildcard `*`, which means we rely on runtime data to know the\n     * actual length of the array.\n     */\n\n\n    Object.keys(node.each).forEach(index => {\n      let child = [];\n\n      if (node.each[index].rules.length) {\n        const pointer = basePath.concat(index).join('.');\n        child.push(this.consumerFn('::tip::', 'literal', node.each[index].rules, [], pointer));\n      }\n\n      child = child.concat(this.walk(node.each[index].children, [], basePath.concat(index)));\n      output = output.concat(this.arrayWrapper(index, field, child, dotPath));\n    });\n    return output;\n  }\n  /**\n   * Walks the schema tree and invokes the `consumerFn` for each node.\n   * The output of the consumer is collected and returned back as an\n   * array.\n   */\n\n\n  walk(schema, dotPath = [], arrayPath = []) {\n    return Object.keys(schema).reduce((result, field) => {\n      const node = schema[field];\n\n      if (node.type === 'literal') {\n        result = result.concat(this.processLiteralNode(field, node, dotPath, arrayPath));\n      }\n\n      if (node.type === 'object') {\n        result = result.concat(this.processObjectNode(field, node, dotPath, arrayPath));\n      }\n\n      if (node.type === 'array') {\n        result = result.concat(this.processArrayNode(field, node, dotPath, arrayPath));\n      }\n\n      return result;\n    }, []);\n  }\n\n}\n\nexports.TreeWalker = TreeWalker;","map":{"version":3,"sources":["/opt/lampp/htdocs/blog-app/node_modules/indicative-compiler/build/src/TreeWalker/index.js"],"names":["Object","defineProperty","exports","value","TreeWalker","constructor","consumerFn","arrayWrapper","processLiteralNode","field","node","dotPath","arrayPath","pointer","concat","join","type","rules","processObjectNode","output","length","push","walk","children","processArrayNode","basePath","keys","each","forEach","index","child","schema","reduce","result"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @module compiler/main\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Tree walker is an agnostic implementation to walk over the parsed schema\n * tree generated by `indicative-parser`.\n *\n * The consumer of the code can define a function to consumer the tree nodes and\n * define another function to wrap the children of an array node.\n *\n * ## Why wrap array children?\n * Since the length of an array is unknown, until we receive the data at\n * runtime, we need a parent function (aka wrapper), that can execute\n * the child validations as per the length of the array.\n *\n * ```js\n * function consumerFn (\n *   field: string,\n *   rules: ParsedRule[],\n *   dotPath: string[],\n *   pointer: string,\n * ) {\n * }\n *\n * function arrayWrapper (\n *   index: string,\n *   field: string,\n *   children: ReturnType<consumerFn>[],\n *   dotPath: string[],\n * ) {\n * }\n *\n * new TreeWalker(consumerFn, arrayWrapper).walk(parsedSchema)\n * ```\n */\nclass TreeWalker {\n    constructor(consumerFn, arrayWrapper) {\n        this.consumerFn = consumerFn;\n        this.arrayWrapper = arrayWrapper;\n    }\n    /**\n     * Processes the literal node inside schema tree\n     */\n    processLiteralNode(field, node, dotPath, arrayPath) {\n        const pointer = arrayPath.concat(dotPath).concat(field).join('.');\n        return this.consumerFn(field, node.type, node.rules, dotPath, pointer);\n    }\n    /**\n     * Process the object node inside the parsed. All children are parsed\n     * recursively\n     */\n    processObjectNode(field, node, dotPath, arrayPath) {\n        let output = [];\n        /**\n         * If object itself has rules, then we need to consume that\n         * as well.\n         */\n        if (node.rules.length) {\n            const pointer = arrayPath.concat(dotPath).concat(field).join('.');\n            output.push(this.consumerFn(field, node.type, node.rules, dotPath, pointer));\n        }\n        /**\n         * Walker over object children\n         */\n        output = output.concat(this.walk(node.children, dotPath.concat(field), arrayPath));\n        return output;\n    }\n    /**\n     * Process the array node of the schema tree. This method will call\n     * the `arrayWrapper` function and passes all array children to it.\n     */\n    processArrayNode(field, node, dotPath, arrayPath) {\n        let output = [];\n        const basePath = arrayPath.concat(dotPath).concat(field);\n        /**\n         * If array itself has rules, then we need to process that\n         * as well\n         */\n        if (node.rules.length) {\n            const pointer = basePath.join('.');\n            output.push(this.consumerFn(field, node.type, node.rules, dotPath, pointer));\n        }\n        /**\n         * Processing children for each index. The index of the tree can be a\n         * wildcard `*`, which means we rely on runtime data to know the\n         * actual length of the array.\n         */\n        Object.keys(node.each).forEach((index) => {\n            let child = [];\n            if (node.each[index].rules.length) {\n                const pointer = basePath.concat(index).join('.');\n                child.push(this.consumerFn('::tip::', 'literal', node.each[index].rules, [], pointer));\n            }\n            child = child.concat(this.walk(node.each[index].children, [], basePath.concat(index)));\n            output = output.concat(this.arrayWrapper(index, field, child, dotPath));\n        });\n        return output;\n    }\n    /**\n     * Walks the schema tree and invokes the `consumerFn` for each node.\n     * The output of the consumer is collected and returned back as an\n     * array.\n     */\n    walk(schema, dotPath = [], arrayPath = []) {\n        return Object.keys(schema).reduce((result, field) => {\n            const node = schema[field];\n            if (node.type === 'literal') {\n                result = result.concat(this.processLiteralNode(field, node, dotPath, arrayPath));\n            }\n            if (node.type === 'object') {\n                result = result.concat(this.processObjectNode(field, node, dotPath, arrayPath));\n            }\n            if (node.type === 'array') {\n                result = result.concat(this.processArrayNode(field, node, dotPath, arrayPath));\n            }\n            return result;\n        }, []);\n    }\n}\nexports.TreeWalker = TreeWalker;\n"]},"metadata":{},"sourceType":"script"}