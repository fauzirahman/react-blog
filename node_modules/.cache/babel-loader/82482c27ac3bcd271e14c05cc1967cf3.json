{"ast":null,"code":"\"use strict\";\n/**\n * @module compiler/sanitizer\n */\n\nvar _defineProperty = require(\"/opt/lampp/htdocs/blog-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/opt/lampp/htdocs/blog-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/lampp/htdocs/blog-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nvar isobject_1 = __importDefault(require(\"isobject\"));\n\nvar lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Runs an array of sanitizations on a given field.\n */\n\n\nvar SanitizationsRunner =\n/*#__PURE__*/\nfunction () {\n  function SanitizationsRunner(field, dotPath, rules, sanitizations) {\n    _classCallCheck(this, SanitizationsRunner);\n\n    this.field = field;\n    this.dotPath = dotPath;\n    this.sanitizations = [];\n    this.computeSanitizations(sanitizations, rules);\n  }\n  /**\n   * Pull sanitizations for the list defined rules.\n   */\n\n\n  _createClass(SanitizationsRunner, [{\n    key: \"computeSanitizations\",\n    value: function computeSanitizations(sanitizations, rules) {\n      this.sanitizations = rules.map(function (rule) {\n        var sanitization = sanitizations[rule.name];\n        /**\n         * Raise exception when sanitization implementation for a\n         * given rule is missing.\n         */\n\n        if (!sanitization) {\n          throw new Error(\"\".concat(rule.name, \" is not a registered as a sanitization\"));\n        }\n        /**\n         * The sanitization node must have a `validate` function.\n         */\n\n\n        if (typeof sanitization.sanitize !== 'function') {\n          throw new Error(\"\".concat(rule.name, \" is missing sanitize function\"));\n        }\n        /**\n         * Mutate args when `compile` function is defined. It is a way to\n         * normalize arguments before the sanitization process kicks in.\n         */\n\n\n        if (typeof sanitization.compile === 'function') {\n          rule.args = sanitization.compile(rule.args);\n        }\n\n        return {\n          rule: rule,\n          fn: sanitization.sanitize\n        };\n      });\n    }\n    /**\n     * Returns a fresh data copy by copying some of the values from the actual\n     * data and then mutating the `tip` and `pointer`. The tip and pointer\n     * are mutated so that the sanitization function receives the closest\n     * object from the pointer, resulting in performant code.\n     */\n\n  }, {\n    key: \"getDataCopy\",\n    value: function getDataCopy(data) {\n      var tip = this.dotPath.length ? lodash_get_1.default(data.tip, this.dotPath) : data.tip;\n      /**\n       * Updating the tip and pointer\n       */\n\n      return Object.assign({}, data, {\n        tip: this.field === '::tip::' ? _defineProperty({}, this.field, tip) : tip\n      });\n    }\n    /**\n     * Execute all sanitization in series for a given filed\n     */\n\n  }, {\n    key: \"exec\",\n    value: function exec(data, config) {\n      var _this = this;\n\n      var dataCopy = this.getDataCopy(data);\n      /**\n       * Skip validations when the parent value of this field is not\n       * an object. The user must validate the parent to be object\n       * seperately.\n       */\n\n      if (!isobject_1.default(dataCopy.tip)) {\n        return;\n      }\n\n      this.sanitizations.forEach(function (sanitization) {\n        sanitization.fn(dataCopy, _this.field, sanitization.rule.args, config);\n      });\n    }\n  }]);\n\n  return SanitizationsRunner;\n}();\n\nexports.SanitizationsRunner = SanitizationsRunner;","map":{"version":3,"sources":["/opt/lampp/htdocs/blog-app/node_modules/indicative-compiler/build/src/Sanitizer/SanitizationsRunner.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","isobject_1","require","lodash_get_1","SanitizationsRunner","field","dotPath","rules","sanitizations","computeSanitizations","map","rule","sanitization","name","Error","sanitize","compile","args","fn","data","tip","length","default","assign","config","dataCopy","getDataCopy","forEach"],"mappings":"AAAA;AACA;;;;;;;;;;AAGA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA;;;;;;;;;AAQA,IAAMC,UAAU,GAAGP,eAAe,CAACQ,OAAO,CAAC,UAAD,CAAR,CAAlC;;AACA,IAAMC,YAAY,GAAGT,eAAe,CAACQ,OAAO,CAAC,YAAD,CAAR,CAApC;AACA;;;;;IAGME,mB;;;AACF,+BAAYC,KAAZ,EAAmBC,OAAnB,EAA4BC,KAA5B,EAAmCC,aAAnC,EAAkD;AAAA;;AAC9C,SAAKH,KAAL,GAAaA,KAAb;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKE,aAAL,GAAqB,EAArB;AACA,SAAKC,oBAAL,CAA0BD,aAA1B,EAAyCD,KAAzC;AACH;AACD;;;;;;;yCAGqBC,a,EAAeD,K,EAAO;AACvC,WAAKC,aAAL,GAAqBD,KAAK,CAACG,GAAN,CAAU,UAACC,IAAD,EAAU;AACrC,YAAMC,YAAY,GAAGJ,aAAa,CAACG,IAAI,CAACE,IAAN,CAAlC;AACA;;;;;AAIA,YAAI,CAACD,YAAL,EAAmB;AACf,gBAAM,IAAIE,KAAJ,WAAaH,IAAI,CAACE,IAAlB,4CAAN;AACH;AACD;;;;;AAGA,YAAI,OAAQD,YAAY,CAACG,QAArB,KAAmC,UAAvC,EAAmD;AAC/C,gBAAM,IAAID,KAAJ,WAAaH,IAAI,CAACE,IAAlB,mCAAN;AACH;AACD;;;;;;AAIA,YAAI,OAAQD,YAAY,CAACI,OAArB,KAAkC,UAAtC,EAAkD;AAC9CL,UAAAA,IAAI,CAACM,IAAL,GAAYL,YAAY,CAACI,OAAb,CAAqBL,IAAI,CAACM,IAA1B,CAAZ;AACH;;AACD,eAAO;AAAEN,UAAAA,IAAI,EAAEA,IAAR;AAAcO,UAAAA,EAAE,EAAEN,YAAY,CAACG;AAA/B,SAAP;AACH,OAvBoB,CAArB;AAwBH;AACD;;;;;;;;;gCAMYI,I,EAAM;AACd,UAAMC,GAAG,GAAG,KAAKd,OAAL,CAAae,MAAb,GAAsBlB,YAAY,CAACmB,OAAb,CAAqBH,IAAI,CAACC,GAA1B,EAA+B,KAAKd,OAApC,CAAtB,GAAqEa,IAAI,CAACC,GAAtF;AACA;;;;AAGA,aAAOvB,MAAM,CAAC0B,MAAP,CAAc,EAAd,EAAkBJ,IAAlB,EAAwB;AAC3BC,QAAAA,GAAG,EAAE,KAAKf,KAAL,KAAe,SAAf,uBAA8B,KAAKA,KAAnC,EAA2Ce,GAA3C,IAAmDA;AAD7B,OAAxB,CAAP;AAGH;AACD;;;;;;yBAGKD,I,EAAMK,M,EAAQ;AAAA;;AACf,UAAMC,QAAQ,GAAG,KAAKC,WAAL,CAAiBP,IAAjB,CAAjB;AACA;;;;;;AAKA,UAAI,CAAClB,UAAU,CAACqB,OAAX,CAAmBG,QAAQ,CAACL,GAA5B,CAAL,EAAuC;AACnC;AACH;;AACD,WAAKZ,aAAL,CAAmBmB,OAAnB,CAA2B,UAACf,YAAD,EAAkB;AACzCA,QAAAA,YAAY,CAACM,EAAb,CAAgBO,QAAhB,EAA0B,KAAI,CAACpB,KAA/B,EAAsCO,YAAY,CAACD,IAAb,CAAkBM,IAAxD,EAA8DO,MAA9D;AACH,OAFD;AAGH;;;;;;AAELzB,OAAO,CAACK,mBAAR,GAA8BA,mBAA9B","sourcesContent":["\"use strict\";\n/**\n * @module compiler/sanitizer\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst isobject_1 = __importDefault(require(\"isobject\"));\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Runs an array of sanitizations on a given field.\n */\nclass SanitizationsRunner {\n    constructor(field, dotPath, rules, sanitizations) {\n        this.field = field;\n        this.dotPath = dotPath;\n        this.sanitizations = [];\n        this.computeSanitizations(sanitizations, rules);\n    }\n    /**\n     * Pull sanitizations for the list defined rules.\n     */\n    computeSanitizations(sanitizations, rules) {\n        this.sanitizations = rules.map((rule) => {\n            const sanitization = sanitizations[rule.name];\n            /**\n             * Raise exception when sanitization implementation for a\n             * given rule is missing.\n             */\n            if (!sanitization) {\n                throw new Error(`${rule.name} is not a registered as a sanitization`);\n            }\n            /**\n             * The sanitization node must have a `validate` function.\n             */\n            if (typeof (sanitization.sanitize) !== 'function') {\n                throw new Error(`${rule.name} is missing sanitize function`);\n            }\n            /**\n             * Mutate args when `compile` function is defined. It is a way to\n             * normalize arguments before the sanitization process kicks in.\n             */\n            if (typeof (sanitization.compile) === 'function') {\n                rule.args = sanitization.compile(rule.args);\n            }\n            return { rule: rule, fn: sanitization.sanitize };\n        });\n    }\n    /**\n     * Returns a fresh data copy by copying some of the values from the actual\n     * data and then mutating the `tip` and `pointer`. The tip and pointer\n     * are mutated so that the sanitization function receives the closest\n     * object from the pointer, resulting in performant code.\n     */\n    getDataCopy(data) {\n        const tip = this.dotPath.length ? lodash_get_1.default(data.tip, this.dotPath) : data.tip;\n        /**\n         * Updating the tip and pointer\n         */\n        return Object.assign({}, data, {\n            tip: this.field === '::tip::' ? { [this.field]: tip } : tip,\n        });\n    }\n    /**\n     * Execute all sanitization in series for a given filed\n     */\n    exec(data, config) {\n        const dataCopy = this.getDataCopy(data);\n        /**\n         * Skip validations when the parent value of this field is not\n         * an object. The user must validate the parent to be object\n         * seperately.\n         */\n        if (!isobject_1.default(dataCopy.tip)) {\n            return;\n        }\n        this.sanitizations.forEach((sanitization) => {\n            sanitization.fn(dataCopy, this.field, sanitization.rule.args, config);\n        });\n    }\n}\nexports.SanitizationsRunner = SanitizationsRunner;\n"]},"metadata":{},"sourceType":"script"}