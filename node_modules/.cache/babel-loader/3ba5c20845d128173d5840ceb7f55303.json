{"ast":null,"code":"\"use strict\";\n/**\n * @module compiler/sanitizer\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Wraps an array of [[SanitizationsRunner]] and executes\n * them based upon the length of an data array at runtime.\n */\n\n\nclass ArrayWrapper {\n  constructor(field, index, childSanitizations, dotPath) {\n    this.field = field;\n    this.index = index;\n    this.childSanitizations = childSanitizations;\n    this.dotPath = dotPath;\n    /**\n     * The pointer to read the value of the field inside the data tip\n     */\n\n    this.pointer = this.dotPath.concat(this.field).join('.');\n  }\n  /**\n   * Returns data copy to the passed to all the children of the array.\n   */\n\n\n  getDataCopy(data) {\n    const value = lodash_get_1.default(data.tip, this.pointer);\n    /**\n     * Ensure value is array, otherwise skip the sanitization process.\n     */\n\n    if (!Array.isArray(value)) {\n      return null;\n    }\n    /**\n     * Since we are adding new properties to the data object. We have\n     * to create a new copy, otherwise the array specific values\n     * will leak this info to other sanitizations as well.\n     */\n\n\n    return {\n      original: data.original,\n      tip: null,\n      parentArray: value,\n      currentIndex: this.index === '*' ? 0 : Number(this.index)\n    };\n  }\n  /**\n   * Executes all sanitizations for a given index value inside the array.\n   */\n\n\n  executeSanitizations(data, config) {\n    this.childSanitizations.forEach(sanitization => sanitization.exec(data, config));\n  }\n  /**\n   * Execute series of sanitizations for values inside an array\n   */\n\n\n  exec(data, config) {\n    const dataCopy = this.getDataCopy(data);\n\n    if (!dataCopy) {\n      return;\n    }\n    /**\n     * If index is a not a wildcard, then we run validations\n     * just for the given index.\n     */\n\n\n    if (this.index !== '*') {\n      dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n      return this.executeSanitizations(dataCopy, config);\n    }\n    /**\n     * Loop over all the entire array and execute validations\n     * for each field.\n     */\n\n\n    dataCopy.parentArray.forEach((item, index) => {\n      dataCopy.tip = item;\n      dataCopy.currentIndex = index;\n      this.executeSanitizations(dataCopy, config);\n    });\n  }\n\n}\n\nexports.ArrayWrapper = ArrayWrapper;","map":{"version":3,"sources":["/opt/lampp/htdocs/react-blog/node_modules/indicative-compiler/build/src/Sanitizer/ArrayWrapper.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","lodash_get_1","require","ArrayWrapper","constructor","field","index","childSanitizations","dotPath","pointer","concat","join","getDataCopy","data","default","tip","Array","isArray","original","parentArray","currentIndex","Number","executeSanitizations","config","forEach","sanitization","exec","dataCopy","item"],"mappings":"AAAA;AACA;;;;AAGA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA;;;;;;;;;AAQA,MAAMC,YAAY,GAAGP,eAAe,CAACQ,OAAO,CAAC,YAAD,CAAR,CAApC;AACA;;;;;;AAIA,MAAMC,YAAN,CAAmB;AACfC,EAAAA,WAAW,CAACC,KAAD,EAAQC,KAAR,EAAeC,kBAAf,EAAmCC,OAAnC,EAA4C;AACnD,SAAKH,KAAL,GAAaA,KAAb;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,kBAAL,GAA0BA,kBAA1B;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA;;;;AAGA,SAAKC,OAAL,GAAe,KAAKD,OAAL,CAAaE,MAAb,CAAoB,KAAKL,KAAzB,EAAgCM,IAAhC,CAAqC,GAArC,CAAf;AACH;AACD;;;;;AAGAC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAMb,KAAK,GAAGC,YAAY,CAACa,OAAb,CAAqBD,IAAI,CAACE,GAA1B,EAA+B,KAAKN,OAApC,CAAd;AACA;;;;AAGA,QAAI,CAACO,KAAK,CAACC,OAAN,CAAcjB,KAAd,CAAL,EAA2B;AACvB,aAAO,IAAP;AACH;AACD;;;;;;;AAKA,WAAO;AACHkB,MAAAA,QAAQ,EAAEL,IAAI,CAACK,QADZ;AAEHH,MAAAA,GAAG,EAAE,IAFF;AAGHI,MAAAA,WAAW,EAAEnB,KAHV;AAIHoB,MAAAA,YAAY,EAAE,KAAKd,KAAL,KAAe,GAAf,GAAqB,CAArB,GAAyBe,MAAM,CAAC,KAAKf,KAAN;AAJ1C,KAAP;AAMH;AACD;;;;;AAGAgB,EAAAA,oBAAoB,CAACT,IAAD,EAAOU,MAAP,EAAe;AAC/B,SAAKhB,kBAAL,CAAwBiB,OAAxB,CAAiCC,YAAD,IAAkBA,YAAY,CAACC,IAAb,CAAkBb,IAAlB,EAAwBU,MAAxB,CAAlD;AACH;AACD;;;;;AAGAG,EAAAA,IAAI,CAACb,IAAD,EAAOU,MAAP,EAAe;AACf,UAAMI,QAAQ,GAAG,KAAKf,WAAL,CAAiBC,IAAjB,CAAjB;;AACA,QAAI,CAACc,QAAL,EAAe;AACX;AACH;AACD;;;;;;AAIA,QAAI,KAAKrB,KAAL,KAAe,GAAnB,EAAwB;AACpBqB,MAAAA,QAAQ,CAACZ,GAAT,GAAeY,QAAQ,CAACR,WAAT,CAAqBQ,QAAQ,CAACP,YAA9B,CAAf;AACA,aAAO,KAAKE,oBAAL,CAA0BK,QAA1B,EAAoCJ,MAApC,CAAP;AACH;AACD;;;;;;AAIAI,IAAAA,QAAQ,CAACR,WAAT,CAAqBK,OAArB,CAA6B,CAACI,IAAD,EAAOtB,KAAP,KAAiB;AAC1CqB,MAAAA,QAAQ,CAACZ,GAAT,GAAea,IAAf;AACAD,MAAAA,QAAQ,CAACP,YAAT,GAAwBd,KAAxB;AACA,WAAKgB,oBAAL,CAA0BK,QAA1B,EAAoCJ,MAApC;AACH,KAJD;AAKH;;AAjEc;;AAmEnBxB,OAAO,CAACI,YAAR,GAAuBA,YAAvB","sourcesContent":["\"use strict\";\n/**\n * @module compiler/sanitizer\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Wraps an array of [[SanitizationsRunner]] and executes\n * them based upon the length of an data array at runtime.\n */\nclass ArrayWrapper {\n    constructor(field, index, childSanitizations, dotPath) {\n        this.field = field;\n        this.index = index;\n        this.childSanitizations = childSanitizations;\n        this.dotPath = dotPath;\n        /**\n         * The pointer to read the value of the field inside the data tip\n         */\n        this.pointer = this.dotPath.concat(this.field).join('.');\n    }\n    /**\n     * Returns data copy to the passed to all the children of the array.\n     */\n    getDataCopy(data) {\n        const value = lodash_get_1.default(data.tip, this.pointer);\n        /**\n         * Ensure value is array, otherwise skip the sanitization process.\n         */\n        if (!Array.isArray(value)) {\n            return null;\n        }\n        /**\n         * Since we are adding new properties to the data object. We have\n         * to create a new copy, otherwise the array specific values\n         * will leak this info to other sanitizations as well.\n         */\n        return {\n            original: data.original,\n            tip: null,\n            parentArray: value,\n            currentIndex: this.index === '*' ? 0 : Number(this.index),\n        };\n    }\n    /**\n     * Executes all sanitizations for a given index value inside the array.\n     */\n    executeSanitizations(data, config) {\n        this.childSanitizations.forEach((sanitization) => sanitization.exec(data, config));\n    }\n    /**\n     * Execute series of sanitizations for values inside an array\n     */\n    exec(data, config) {\n        const dataCopy = this.getDataCopy(data);\n        if (!dataCopy) {\n            return;\n        }\n        /**\n         * If index is a not a wildcard, then we run validations\n         * just for the given index.\n         */\n        if (this.index !== '*') {\n            dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n            return this.executeSanitizations(dataCopy, config);\n        }\n        /**\n         * Loop over all the entire array and execute validations\n         * for each field.\n         */\n        dataCopy.parentArray.forEach((item, index) => {\n            dataCopy.tip = item;\n            dataCopy.currentIndex = index;\n            this.executeSanitizations(dataCopy, config);\n        });\n    }\n}\nexports.ArrayWrapper = ArrayWrapper;\n"]},"metadata":{},"sourceType":"script"}