{"ast":null,"code":"\"use strict\";\n/**\n * @module compiler/validator\n */\n\nvar _regeneratorRuntime = require(\"/opt/lampp/htdocs/react-blog/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/opt/lampp/htdocs/react-blog/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/opt/lampp/htdocs/react-blog/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/lampp/htdocs/react-blog/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nvar lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Wraps the [[ValidationsRunner]] and executes them based upon the length of\n * an array at runtime.\n */\n\n\nvar ArrayWrapper =\n/*#__PURE__*/\nfunction () {\n  function ArrayWrapper(field, index, childrenValidators, dotPath) {\n    _classCallCheck(this, ArrayWrapper);\n\n    this.field = field;\n    this.index = index;\n    this.childrenValidators = childrenValidators;\n    this.dotPath = dotPath;\n    /**\n     * The pointer to read the value of the field inside the data tip\n     */\n\n    this.pointer = this.dotPath.concat(this.field).join('.');\n    /**\n     * A boolean to know if any of the children inside the wrapper\n     * has async validators.\n     */\n\n    this.async = !!this.childrenValidators.find(function (validator) {\n      return validator.async;\n    });\n  }\n  /**\n   * Returns data copy to the passed to all the children of the\n   * array.\n   */\n\n\n  _createClass(ArrayWrapper, [{\n    key: \"getDataCopy\",\n    value: function getDataCopy(data) {\n      var value = lodash_get_1.default(data.tip, this.pointer);\n      /**\n       * Ensure value is array, otherwise mark the validation as passed.\n       * The top level value must be validated for an array for same.\n       */\n\n      if (!Array.isArray(value)) {\n        return null;\n      }\n      /**\n       * Since we are adding new properties to the data object. We have\n       * to create a new copy, otherwise the array specific values\n       * will leak this info to other validations as well.\n       */\n\n\n      return {\n        original: data.original,\n        pointer: '',\n        tip: null,\n        parentArray: value,\n        currentIndex: this.index === '*' ? 0 : Number(this.index),\n        arrayPointer: data.arrayPointer ? \"\".concat(data.arrayPointer, \".\").concat(data.currentIndex, \".\").concat(this.pointer) : this.pointer\n      };\n    }\n    /**\n     * Executes all validations for a given index value inside the array.\n     */\n\n  }, {\n    key: \"executeValidations\",\n    value: function executeValidations(data, collector, config, bail) {\n      var hasFailures = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.childrenValidators[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var validator = _step.value;\n          var passed = validator.exec(data, collector, config, bail);\n\n          if (!passed) {\n            hasFailures = true;\n\n            if (bail) {\n              break;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return !hasFailures;\n    }\n    /**\n     * Same as [[ArrayWrapper.executeValidations]] but async.\n     */\n\n  }, {\n    key: \"executeAsyncValidations\",\n    value: function () {\n      var _executeAsyncValidations = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(data, collector, config, bail) {\n        var hasFailures, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, validator, passed;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                hasFailures = false;\n                _iteratorNormalCompletion2 = true;\n                _didIteratorError2 = false;\n                _iteratorError2 = undefined;\n                _context.prev = 4;\n                _iterator2 = this.childrenValidators[Symbol.iterator]();\n\n              case 6:\n                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                  _context.next = 23;\n                  break;\n                }\n\n                validator = _step2.value;\n                passed = true;\n\n                if (!validator.async) {\n                  _context.next = 15;\n                  break;\n                }\n\n                _context.next = 12;\n                return validator.execAsync(data, collector, config, bail);\n\n              case 12:\n                passed = _context.sent;\n                _context.next = 16;\n                break;\n\n              case 15:\n                passed = validator.exec(data, collector, config, bail);\n\n              case 16:\n                if (passed) {\n                  _context.next = 20;\n                  break;\n                }\n\n                hasFailures = true;\n\n                if (!bail) {\n                  _context.next = 20;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 23);\n\n              case 20:\n                _iteratorNormalCompletion2 = true;\n                _context.next = 6;\n                break;\n\n              case 23:\n                _context.next = 29;\n                break;\n\n              case 25:\n                _context.prev = 25;\n                _context.t0 = _context[\"catch\"](4);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context.t0;\n\n              case 29:\n                _context.prev = 29;\n                _context.prev = 30;\n\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n\n              case 32:\n                _context.prev = 32;\n\n                if (!_didIteratorError2) {\n                  _context.next = 35;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 35:\n                return _context.finish(32);\n\n              case 36:\n                return _context.finish(29);\n\n              case 37:\n                return _context.abrupt(\"return\", !hasFailures);\n\n              case 38:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 25, 29, 37], [30,, 32, 36]]);\n      }));\n\n      function executeAsyncValidations(_x, _x2, _x3, _x4) {\n        return _executeAsyncValidations.apply(this, arguments);\n      }\n\n      return executeAsyncValidations;\n    }()\n    /**\n     * Execute series of validations for values inside an array\n     */\n\n  }, {\n    key: \"exec\",\n    value: function exec(data, collector, config) {\n      var bail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var dataCopy = this.getDataCopy(data);\n\n      if (!dataCopy) {\n        return true;\n      }\n      /**\n       * If index is a not a wildcard, then we run validations\n       * just for the given index.\n       */\n\n\n      if (this.index !== '*') {\n        dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n        return this.executeValidations(dataCopy, collector, config, bail);\n      }\n\n      var index = 0;\n      var hasFailures = false;\n      /**\n       * Loop over all the entire array and execute validations\n       * for each field.\n       */\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = dataCopy.parentArray[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var item = _step3.value;\n          dataCopy.tip = item;\n          dataCopy.currentIndex = index;\n          var passed = true;\n          passed = this.executeValidations(dataCopy, collector, config, bail);\n\n          if (!passed) {\n            hasFailures = true;\n\n            if (bail) {\n              break;\n            }\n          }\n\n          index++;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return !hasFailures;\n    }\n    /**\n     * Execute series of async validations for values inside an array. Same\n     * as [[ArrayWrapper.exec]] but async.\n     */\n\n  }, {\n    key: \"execAsync\",\n    value: function () {\n      var _execAsync = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(data, collector, config) {\n        var bail,\n            dataCopy,\n            index,\n            hasFailures,\n            _iteratorNormalCompletion4,\n            _didIteratorError4,\n            _iteratorError4,\n            _iterator4,\n            _step4,\n            item,\n            passed,\n            _args2 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                bail = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : false;\n                dataCopy = this.getDataCopy(data);\n\n                if (dataCopy) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", true);\n\n              case 4:\n                if (!(this.index !== '*')) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n                return _context2.abrupt(\"return\", this.executeAsyncValidations(dataCopy, collector, config, bail));\n\n              case 7:\n                index = 0;\n                hasFailures = false;\n                /**\n                 * Loop over all the entire array and execute validations\n                 * for each field.\n                 */\n\n                _iteratorNormalCompletion4 = true;\n                _didIteratorError4 = false;\n                _iteratorError4 = undefined;\n                _context2.prev = 12;\n                _iterator4 = dataCopy.parentArray[Symbol.iterator]();\n\n              case 14:\n                if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n                  _context2.next = 29;\n                  break;\n                }\n\n                item = _step4.value;\n                dataCopy.tip = item;\n                dataCopy.currentIndex = index;\n                _context2.next = 20;\n                return this.executeAsyncValidations(dataCopy, collector, config, bail);\n\n              case 20:\n                passed = _context2.sent;\n\n                if (passed) {\n                  _context2.next = 25;\n                  break;\n                }\n\n                hasFailures = true;\n\n                if (!bail) {\n                  _context2.next = 25;\n                  break;\n                }\n\n                return _context2.abrupt(\"break\", 29);\n\n              case 25:\n                index++;\n\n              case 26:\n                _iteratorNormalCompletion4 = true;\n                _context2.next = 14;\n                break;\n\n              case 29:\n                _context2.next = 35;\n                break;\n\n              case 31:\n                _context2.prev = 31;\n                _context2.t0 = _context2[\"catch\"](12);\n                _didIteratorError4 = true;\n                _iteratorError4 = _context2.t0;\n\n              case 35:\n                _context2.prev = 35;\n                _context2.prev = 36;\n\n                if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                  _iterator4.return();\n                }\n\n              case 38:\n                _context2.prev = 38;\n\n                if (!_didIteratorError4) {\n                  _context2.next = 41;\n                  break;\n                }\n\n                throw _iteratorError4;\n\n              case 41:\n                return _context2.finish(38);\n\n              case 42:\n                return _context2.finish(35);\n\n              case 43:\n                return _context2.abrupt(\"return\", !hasFailures);\n\n              case 44:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[12, 31, 35, 43], [36,, 38, 42]]);\n      }));\n\n      function execAsync(_x5, _x6, _x7) {\n        return _execAsync.apply(this, arguments);\n      }\n\n      return execAsync;\n    }()\n  }]);\n\n  return ArrayWrapper;\n}();\n\nexports.ArrayWrapper = ArrayWrapper;","map":{"version":3,"sources":["/opt/lampp/htdocs/react-blog/node_modules/indicative-compiler/build/src/Validator/ArrayWrapper.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","lodash_get_1","require","ArrayWrapper","field","index","childrenValidators","dotPath","pointer","concat","join","async","find","validator","data","default","tip","Array","isArray","original","parentArray","currentIndex","Number","arrayPointer","collector","config","bail","hasFailures","passed","exec","execAsync","dataCopy","getDataCopy","executeValidations","item","executeAsyncValidations"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @module compiler/validator\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Wraps the [[ValidationsRunner]] and executes them based upon the length of\n * an array at runtime.\n */\nclass ArrayWrapper {\n    constructor(field, index, childrenValidators, dotPath) {\n        this.field = field;\n        this.index = index;\n        this.childrenValidators = childrenValidators;\n        this.dotPath = dotPath;\n        /**\n         * The pointer to read the value of the field inside the data tip\n         */\n        this.pointer = this.dotPath.concat(this.field).join('.');\n        /**\n         * A boolean to know if any of the children inside the wrapper\n         * has async validators.\n         */\n        this.async = !!this.childrenValidators.find((validator) => validator.async);\n    }\n    /**\n     * Returns data copy to the passed to all the children of the\n     * array.\n     */\n    getDataCopy(data) {\n        const value = lodash_get_1.default(data.tip, this.pointer);\n        /**\n         * Ensure value is array, otherwise mark the validation as passed.\n         * The top level value must be validated for an array for same.\n         */\n        if (!Array.isArray(value)) {\n            return null;\n        }\n        /**\n         * Since we are adding new properties to the data object. We have\n         * to create a new copy, otherwise the array specific values\n         * will leak this info to other validations as well.\n         */\n        return {\n            original: data.original,\n            pointer: '',\n            tip: null,\n            parentArray: value,\n            currentIndex: this.index === '*' ? 0 : Number(this.index),\n            arrayPointer: data.arrayPointer\n                ? `${data.arrayPointer}.${data.currentIndex}.${this.pointer}`\n                : this.pointer,\n        };\n    }\n    /**\n     * Executes all validations for a given index value inside the array.\n     */\n    executeValidations(data, collector, config, bail) {\n        let hasFailures = false;\n        for (let validator of this.childrenValidators) {\n            const passed = validator.exec(data, collector, config, bail);\n            if (!passed) {\n                hasFailures = true;\n                if (bail) {\n                    break;\n                }\n            }\n        }\n        return !hasFailures;\n    }\n    /**\n     * Same as [[ArrayWrapper.executeValidations]] but async.\n     */\n    async executeAsyncValidations(data, collector, config, bail) {\n        let hasFailures = false;\n        for (let validator of this.childrenValidators) {\n            let passed = true;\n            if (validator.async) {\n                passed = await validator.execAsync(data, collector, config, bail);\n            }\n            else {\n                passed = validator.exec(data, collector, config, bail);\n            }\n            if (!passed) {\n                hasFailures = true;\n                if (bail) {\n                    break;\n                }\n            }\n        }\n        return !hasFailures;\n    }\n    /**\n     * Execute series of validations for values inside an array\n     */\n    exec(data, collector, config, bail = false) {\n        const dataCopy = this.getDataCopy(data);\n        if (!dataCopy) {\n            return true;\n        }\n        /**\n         * If index is a not a wildcard, then we run validations\n         * just for the given index.\n         */\n        if (this.index !== '*') {\n            dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n            return this.executeValidations(dataCopy, collector, config, bail);\n        }\n        let index = 0;\n        let hasFailures = false;\n        /**\n         * Loop over all the entire array and execute validations\n         * for each field.\n         */\n        for (let item of dataCopy.parentArray) {\n            dataCopy.tip = item;\n            dataCopy.currentIndex = index;\n            let passed = true;\n            passed = this.executeValidations(dataCopy, collector, config, bail);\n            if (!passed) {\n                hasFailures = true;\n                if (bail) {\n                    break;\n                }\n            }\n            index++;\n        }\n        return !hasFailures;\n    }\n    /**\n     * Execute series of async validations for values inside an array. Same\n     * as [[ArrayWrapper.exec]] but async.\n     */\n    async execAsync(data, collector, config, bail = false) {\n        const dataCopy = this.getDataCopy(data);\n        if (!dataCopy) {\n            return true;\n        }\n        /**\n         * If index is a not a wildcard, then we run validations\n         * just for the given index.\n         */\n        if (this.index !== '*') {\n            dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n            return this.executeAsyncValidations(dataCopy, collector, config, bail);\n        }\n        let index = 0;\n        let hasFailures = false;\n        /**\n         * Loop over all the entire array and execute validations\n         * for each field.\n         */\n        for (let item of dataCopy.parentArray) {\n            dataCopy.tip = item;\n            dataCopy.currentIndex = index;\n            const passed = await this.executeAsyncValidations(dataCopy, collector, config, bail);\n            if (!passed) {\n                hasFailures = true;\n                if (bail) {\n                    break;\n                }\n            }\n            index++;\n        }\n        return !hasFailures;\n    }\n}\nexports.ArrayWrapper = ArrayWrapper;\n"]},"metadata":{},"sourceType":"script"}