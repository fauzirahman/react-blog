{"ast":null,"code":"\"use strict\";\n/**\n * @module compiler/validator\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nconst isobject_1 = __importDefault(require(\"isobject\"));\n\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Runs a series of validations on a given field. This class is feeded with the\n * computed nodes generated via [[TreeWalker]].\n */\n\n\nclass ValidationsRunner {\n  constructor(field, type, dotPath, rules, validations, fieldMessages, genericMessages) {\n    this.field = field;\n    this.type = type;\n    this.dotPath = dotPath;\n    this.fieldMessages = fieldMessages;\n    this.genericMessages = genericMessages;\n    /**\n     * We toggle this flag then creating the `validations` object\n     */\n\n    this.async = false;\n    /**\n     * Collection of validations to be executed on a given field.\n     */\n\n    this.validations = [];\n    /**\n     * Base pointer to this field. When field is inside an\n     * array, then we need to re-compute the pointer\n     * based upon the current index in which this\n     * field is validated.\n     *\n     * However, we don't mutate this field.\n     */\n\n    this.pointer = this.dotPath.concat(this.field).join('.');\n    this.computeValidations(validations, rules);\n  }\n  /**\n   * Creating a list of validation functions to be executed as per\n   * the defined rules.\n   */\n\n\n  computeValidations(validations, rules) {\n    this.validations = rules.map(rule => {\n      const validation = validations[rule.name];\n      /**\n       * Raise exception when validation implementation for a\n       * given rule is missing.\n       */\n\n      if (!validation) {\n        throw new Error(`${rule.name} is not a registered as a validation`);\n      }\n      /**\n       * The validation node must have a `validate` function.\n       */\n\n\n      if (typeof validation.validate !== 'function') {\n        throw new Error(`${rule.name} is missing validate function`);\n      }\n      /**\n       * Mutate args when `compile` function is defined. It is a way to\n       * normalize arguments before the validation process kicks in.\n       */\n\n\n      if (typeof validation.compile === 'function') {\n        rule.args = validation.compile(rule.args);\n      }\n      /**\n       * Set the flag to `true` when one or more validations are `async`.\n       * This tells the consumer of [[ValidationsRunner]] class to make\n       * use of `execAsync` over `exec`. All done for performance.\n       */\n\n\n      if (validation.async) {\n        this.async = true;\n      }\n\n      return {\n        rule: rule,\n        fn: validation.validate,\n        async: validation.async\n      };\n    });\n  }\n  /**\n   * Returns a fresh data copy by copying some of the values from the actual\n   * data and then mutating the `tip` and `pointer`. The tip and pointer\n   * are mutated so that the validation function receives the closest\n   * object from the pointer, resulting in performant code.\n   */\n\n\n  getDataCopy(data) {\n    const tip = this.dotPath.length ? lodash_get_1.default(data.tip, this.dotPath) : data.tip;\n    /**\n     * Prefix array pointer and current index, when this field is part\n     * of an array.\n     * Also do not append the pointer when pointer is `::tip::`\n     */\n\n    const pointer = data.arrayPointer ? this.pointer === '::tip::' ? `${data.arrayPointer}.${data.currentIndex}` : `${data.arrayPointer}.${data.currentIndex}.${this.pointer}` : this.pointer;\n    /**\n     * Updating the tip and pointer\n     */\n\n    return Object.assign({}, data, {\n      tip: this.field === '::tip::' ? {\n        [this.field]: tip\n      } : tip,\n      pointer: pointer\n    });\n  }\n  /**\n   * Reports value to the collector when current field is a literal\n   * node inside the tree and validation has passed\n   */\n\n\n  reportValueToCollector(passed, data, collector) {\n    if (!passed || this.type !== 'literal') {\n      return;\n    }\n\n    collector.setValue(data.pointer, data.tip[this.field]);\n  }\n  /**\n   * Reports the validation error to the collector.\n   */\n\n\n  reportErrorToCollector(pointer, rule, collector, exception) {\n    const message = exception || this.fieldMessages[rule.name] || this.genericMessages[rule.name];\n    collector.setError(pointer, rule, message);\n  }\n  /**\n   * Executes all the validations on a given field synchronously. Run\n   * [[ValidationsRunner.execAsync]] if want to execute asynchronously.\n   */\n\n\n  exec(data, collector, config, bail = false) {\n    const dataCopy = this.getDataCopy(data);\n    /**\n     * Skip validations when the parent value of this field is not\n     * an object. The user must validate the parent to be object\n     * seperately.\n     */\n\n    if (!isobject_1.default(dataCopy.tip)) {\n      return true;\n    }\n\n    let hasFailures = false;\n    /**\n     * Sequentially loop over all the validations.\n     * We break the loop, when `bail=true`.\n     */\n\n    for (let validation of this.validations) {\n      let exception = null;\n      let passed = true;\n      /**\n       * Wrapping the validation function for unexpected errors.\n       */\n\n      try {\n        passed = validation.fn(dataCopy, this.field, validation.rule.args, config);\n      } catch (error) {\n        exception = error;\n        passed = false;\n      }\n\n      if (!passed) {\n        hasFailures = true;\n        this.reportErrorToCollector(dataCopy.pointer, validation.rule, collector, exception);\n\n        if (bail) {\n          break;\n        }\n      }\n    }\n\n    this.reportValueToCollector(!hasFailures, dataCopy, collector);\n    return !hasFailures;\n  }\n  /**\n   * Executes all the validations on a given field asynchronously. Run\n   * [[ValidationsRunner.exec]] if want to execute synchronously.\n   */\n\n\n  async execAsync(data, collector, config, bail = false) {\n    const dataCopy = this.getDataCopy(data);\n    /**\n     * Skip validations when the parent value of this field is not\n     * an object. The user must validate the parent to be object\n     * seperately.\n     */\n\n    if (!isobject_1.default(dataCopy.tip)) {\n      return true;\n    }\n\n    let hasFailures = false;\n    /**\n     * Sequentially loop over all the validations.\n     * We break the loop, when `bail=true`.\n     */\n\n    for (let validation of this.validations) {\n      let exception = null;\n      let passed = true;\n\n      try {\n        if (validation.async) {\n          passed = await validation.fn(dataCopy, this.field, validation.rule.args, config);\n        } else {\n          passed = validation.fn(dataCopy, this.field, validation.rule.args, config);\n        }\n      } catch (error) {\n        passed = false;\n        exception = error;\n      }\n\n      if (!passed) {\n        hasFailures = true;\n        this.reportErrorToCollector(dataCopy.pointer, validation.rule, collector, exception);\n\n        if (bail) {\n          break;\n        }\n      }\n    }\n\n    this.reportValueToCollector(!hasFailures, dataCopy, collector);\n    return !hasFailures;\n  }\n\n}\n\nexports.ValidationsRunner = ValidationsRunner;","map":{"version":3,"sources":["/opt/lampp/htdocs/blog-app/node_modules/indicative-compiler/build/src/Validator/ValidationsRunner.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","isobject_1","require","lodash_get_1","ValidationsRunner","constructor","field","type","dotPath","rules","validations","fieldMessages","genericMessages","async","pointer","concat","join","computeValidations","map","rule","validation","name","Error","validate","compile","args","fn","getDataCopy","data","tip","length","default","arrayPointer","currentIndex","assign","reportValueToCollector","passed","collector","setValue","reportErrorToCollector","exception","message","setError","exec","config","bail","dataCopy","hasFailures","error","execAsync"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @module compiler/validator\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst isobject_1 = __importDefault(require(\"isobject\"));\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Runs a series of validations on a given field. This class is feeded with the\n * computed nodes generated via [[TreeWalker]].\n */\nclass ValidationsRunner {\n    constructor(field, type, dotPath, rules, validations, fieldMessages, genericMessages) {\n        this.field = field;\n        this.type = type;\n        this.dotPath = dotPath;\n        this.fieldMessages = fieldMessages;\n        this.genericMessages = genericMessages;\n        /**\n         * We toggle this flag then creating the `validations` object\n         */\n        this.async = false;\n        /**\n         * Collection of validations to be executed on a given field.\n         */\n        this.validations = [];\n        /**\n         * Base pointer to this field. When field is inside an\n         * array, then we need to re-compute the pointer\n         * based upon the current index in which this\n         * field is validated.\n         *\n         * However, we don't mutate this field.\n         */\n        this.pointer = this.dotPath.concat(this.field).join('.');\n        this.computeValidations(validations, rules);\n    }\n    /**\n     * Creating a list of validation functions to be executed as per\n     * the defined rules.\n     */\n    computeValidations(validations, rules) {\n        this.validations = rules.map((rule) => {\n            const validation = validations[rule.name];\n            /**\n             * Raise exception when validation implementation for a\n             * given rule is missing.\n             */\n            if (!validation) {\n                throw new Error(`${rule.name} is not a registered as a validation`);\n            }\n            /**\n             * The validation node must have a `validate` function.\n             */\n            if (typeof (validation.validate) !== 'function') {\n                throw new Error(`${rule.name} is missing validate function`);\n            }\n            /**\n             * Mutate args when `compile` function is defined. It is a way to\n             * normalize arguments before the validation process kicks in.\n             */\n            if (typeof (validation.compile) === 'function') {\n                rule.args = validation.compile(rule.args);\n            }\n            /**\n             * Set the flag to `true` when one or more validations are `async`.\n             * This tells the consumer of [[ValidationsRunner]] class to make\n             * use of `execAsync` over `exec`. All done for performance.\n             */\n            if (validation.async) {\n                this.async = true;\n            }\n            return { rule: rule, fn: validation.validate, async: validation.async };\n        });\n    }\n    /**\n     * Returns a fresh data copy by copying some of the values from the actual\n     * data and then mutating the `tip` and `pointer`. The tip and pointer\n     * are mutated so that the validation function receives the closest\n     * object from the pointer, resulting in performant code.\n     */\n    getDataCopy(data) {\n        const tip = this.dotPath.length ? lodash_get_1.default(data.tip, this.dotPath) : data.tip;\n        /**\n         * Prefix array pointer and current index, when this field is part\n         * of an array.\n         * Also do not append the pointer when pointer is `::tip::`\n         */\n        const pointer = data.arrayPointer ?\n            (this.pointer === '::tip::'\n                ? `${data.arrayPointer}.${data.currentIndex}`\n                : `${data.arrayPointer}.${data.currentIndex}.${this.pointer}`)\n            : this.pointer;\n        /**\n         * Updating the tip and pointer\n         */\n        return Object.assign({}, data, {\n            tip: this.field === '::tip::' ? { [this.field]: tip } : tip,\n            pointer: pointer,\n        });\n    }\n    /**\n     * Reports value to the collector when current field is a literal\n     * node inside the tree and validation has passed\n     */\n    reportValueToCollector(passed, data, collector) {\n        if (!passed || this.type !== 'literal') {\n            return;\n        }\n        collector.setValue(data.pointer, data.tip[this.field]);\n    }\n    /**\n     * Reports the validation error to the collector.\n     */\n    reportErrorToCollector(pointer, rule, collector, exception) {\n        const message = exception || this.fieldMessages[rule.name] || this.genericMessages[rule.name];\n        collector.setError(pointer, rule, message);\n    }\n    /**\n     * Executes all the validations on a given field synchronously. Run\n     * [[ValidationsRunner.execAsync]] if want to execute asynchronously.\n     */\n    exec(data, collector, config, bail = false) {\n        const dataCopy = this.getDataCopy(data);\n        /**\n         * Skip validations when the parent value of this field is not\n         * an object. The user must validate the parent to be object\n         * seperately.\n         */\n        if (!isobject_1.default(dataCopy.tip)) {\n            return true;\n        }\n        let hasFailures = false;\n        /**\n         * Sequentially loop over all the validations.\n         * We break the loop, when `bail=true`.\n         */\n        for (let validation of this.validations) {\n            let exception = null;\n            let passed = true;\n            /**\n             * Wrapping the validation function for unexpected errors.\n             */\n            try {\n                passed = validation.fn(dataCopy, this.field, validation.rule.args, config);\n            }\n            catch (error) {\n                exception = error;\n                passed = false;\n            }\n            if (!passed) {\n                hasFailures = true;\n                this.reportErrorToCollector(dataCopy.pointer, validation.rule, collector, exception);\n                if (bail) {\n                    break;\n                }\n            }\n        }\n        this.reportValueToCollector(!hasFailures, dataCopy, collector);\n        return !hasFailures;\n    }\n    /**\n     * Executes all the validations on a given field asynchronously. Run\n     * [[ValidationsRunner.exec]] if want to execute synchronously.\n     */\n    async execAsync(data, collector, config, bail = false) {\n        const dataCopy = this.getDataCopy(data);\n        /**\n         * Skip validations when the parent value of this field is not\n         * an object. The user must validate the parent to be object\n         * seperately.\n         */\n        if (!isobject_1.default(dataCopy.tip)) {\n            return true;\n        }\n        let hasFailures = false;\n        /**\n         * Sequentially loop over all the validations.\n         * We break the loop, when `bail=true`.\n         */\n        for (let validation of this.validations) {\n            let exception = null;\n            let passed = true;\n            try {\n                if (validation.async) {\n                    passed = await validation.fn(dataCopy, this.field, validation.rule.args, config);\n                }\n                else {\n                    passed = validation.fn(dataCopy, this.field, validation.rule.args, config);\n                }\n            }\n            catch (error) {\n                passed = false;\n                exception = error;\n            }\n            if (!passed) {\n                hasFailures = true;\n                this.reportErrorToCollector(dataCopy.pointer, validation.rule, collector, exception);\n                if (bail) {\n                    break;\n                }\n            }\n        }\n        this.reportValueToCollector(!hasFailures, dataCopy, collector);\n        return !hasFailures;\n    }\n}\nexports.ValidationsRunner = ValidationsRunner;\n"]},"metadata":{},"sourceType":"script"}