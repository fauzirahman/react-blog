{"ast":null,"code":"\"use strict\";\n/*\n* indicative-rules\n*\n* (c) Harminder Virk <virk@adonisjs.com>\n*\n* For the full copyright and license information, please view the LICENSE\n* file that was distributed with this source code.\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar indicative_utils_1 = require(\"indicative-utils\");\n\nvar same_1 = require(\"../../raw/same\");\n\nfunction castType(input, type) {\n  if (type === 'string') {\n    return indicative_utils_1.cast(input, 'string');\n  }\n\n  if (type === 'number') {\n    return indicative_utils_1.cast(input, 'integer');\n  }\n\n  return input;\n}\n/**\n * Checks whether the field has been confirmed with same value or not using\n * the `_confirmation` convention. For example:\n *\n * The `password_confirmation` must exist and have the same value as the\n * `password` field.\n *\n * ```ts\n * import { validations } from 'indicative/validator'\n *\n * const rules = {\n *   password: 'confirmed'\n * }\n *\n * // or\n * const rules = {\n *   password: [\n *     validations.confirmed()\n *   ]\n * }\n * ```\n */\n\n\nvar validation = {\n  async: false,\n  validate: function validate(data, field, _args, config) {\n    var fieldValue = indicative_utils_1.getValue(data, field);\n\n    if (indicative_utils_1.skippable(fieldValue, field, config)) {\n      return true;\n    }\n\n    var valueType = typeof fieldValue;\n    var comparisonValue = indicative_utils_1.getValue(data, \"\".concat(field, \"_confirmation\"));\n    /**\n     * Cast type of comparison value when types are different. This is\n     * important since the end-user has no way to cast type of the\n     * confirmed field. For example:\n     *\n     * 1. Add `number` rule to the `pincode` field, which will cast the\n     *    pincode to `number`.\n     * 2. Also add `confirmed` rule to `pincode`, now you cannot cast\n     *    it's value, so we need to do type conversion here.\n     */\n\n    /* eslint \"valid-typeof\": \"off\" */\n\n    if (typeof comparisonValue !== valueType) {\n      comparisonValue = castType(comparisonValue, valueType);\n    }\n\n    return same_1.same(fieldValue, comparisonValue);\n  }\n};\nexports.default = validation;","map":{"version":3,"sources":["/opt/lampp/htdocs/blog-app/node_modules/indicative-rules/build/src/validations/primitives/confirmed.js"],"names":["Object","defineProperty","exports","value","indicative_utils_1","require","same_1","castType","input","type","cast","validation","async","validate","data","field","_args","config","fieldValue","getValue","skippable","valueType","comparisonValue","same","default"],"mappings":"AAAA;AACA;;;;;;;;;AAQAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAMC,kBAAkB,GAAGC,OAAO,CAAC,kBAAD,CAAlC;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,gBAAD,CAAtB;;AACA,SAASE,QAAT,CAAkBC,KAAlB,EAAyBC,IAAzB,EAA+B;AAC3B,MAAIA,IAAI,KAAK,QAAb,EAAuB;AACnB,WAAOL,kBAAkB,CAACM,IAAnB,CAAwBF,KAAxB,EAA+B,QAA/B,CAAP;AACH;;AACD,MAAIC,IAAI,KAAK,QAAb,EAAuB;AACnB,WAAOL,kBAAkB,CAACM,IAAnB,CAAwBF,KAAxB,EAA+B,SAA/B,CAAP;AACH;;AACD,SAAOA,KAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;;AAsBA,IAAMG,UAAU,GAAG;AACfC,EAAAA,KAAK,EAAE,KADQ;AAEfC,EAAAA,QAAQ,EAAE,kBAACC,IAAD,EAAOC,KAAP,EAAcC,KAAd,EAAqBC,MAArB,EAAgC;AACtC,QAAMC,UAAU,GAAGd,kBAAkB,CAACe,QAAnB,CAA4BL,IAA5B,EAAkCC,KAAlC,CAAnB;;AACA,QAAIX,kBAAkB,CAACgB,SAAnB,CAA6BF,UAA7B,EAAyCH,KAAzC,EAAgDE,MAAhD,CAAJ,EAA6D;AACzD,aAAO,IAAP;AACH;;AACD,QAAMI,SAAS,GAAG,OAAQH,UAA1B;AACA,QAAII,eAAe,GAAGlB,kBAAkB,CAACe,QAAnB,CAA4BL,IAA5B,YAAqCC,KAArC,mBAAtB;AACA;;;;;;;;;;;AAUA;;AACA,QAAI,OAAQO,eAAR,KAA6BD,SAAjC,EAA4C;AACxCC,MAAAA,eAAe,GAAGf,QAAQ,CAACe,eAAD,EAAkBD,SAAlB,CAA1B;AACH;;AACD,WAAOf,MAAM,CAACiB,IAAP,CAAYL,UAAZ,EAAwBI,eAAxB,CAAP;AACH;AAxBc,CAAnB;AA0BApB,OAAO,CAACsB,OAAR,GAAkBb,UAAlB","sourcesContent":["\"use strict\";\n/*\n* indicative-rules\n*\n* (c) Harminder Virk <virk@adonisjs.com>\n*\n* For the full copyright and license information, please view the LICENSE\n* file that was distributed with this source code.\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst indicative_utils_1 = require(\"indicative-utils\");\nconst same_1 = require(\"../../raw/same\");\nfunction castType(input, type) {\n    if (type === 'string') {\n        return indicative_utils_1.cast(input, 'string');\n    }\n    if (type === 'number') {\n        return indicative_utils_1.cast(input, 'integer');\n    }\n    return input;\n}\n/**\n * Checks whether the field has been confirmed with same value or not using\n * the `_confirmation` convention. For example:\n *\n * The `password_confirmation` must exist and have the same value as the\n * `password` field.\n *\n * ```ts\n * import { validations } from 'indicative/validator'\n *\n * const rules = {\n *   password: 'confirmed'\n * }\n *\n * // or\n * const rules = {\n *   password: [\n *     validations.confirmed()\n *   ]\n * }\n * ```\n */\nconst validation = {\n    async: false,\n    validate: (data, field, _args, config) => {\n        const fieldValue = indicative_utils_1.getValue(data, field);\n        if (indicative_utils_1.skippable(fieldValue, field, config)) {\n            return true;\n        }\n        const valueType = typeof (fieldValue);\n        let comparisonValue = indicative_utils_1.getValue(data, `${field}_confirmation`);\n        /**\n         * Cast type of comparison value when types are different. This is\n         * important since the end-user has no way to cast type of the\n         * confirmed field. For example:\n         *\n         * 1. Add `number` rule to the `pincode` field, which will cast the\n         *    pincode to `number`.\n         * 2. Also add `confirmed` rule to `pincode`, now you cannot cast\n         *    it's value, so we need to do type conversion here.\n         */\n        /* eslint \"valid-typeof\": \"off\" */\n        if (typeof (comparisonValue) !== valueType) {\n            comparisonValue = castType(comparisonValue, valueType);\n        }\n        return same_1.same(fieldValue, comparisonValue);\n    },\n};\nexports.default = validation;\n"]},"metadata":{},"sourceType":"script"}