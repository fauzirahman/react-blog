{"ast":null,"code":"\"use strict\";\n/**\n * @module compiler/sanitizer\n */\n\nvar _classCallCheck = require(\"/opt/lampp/htdocs/react-blog/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/lampp/htdocs/react-blog/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nvar lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Wraps an array of [[SanitizationsRunner]] and executes\n * them based upon the length of an data array at runtime.\n */\n\n\nvar ArrayWrapper =\n/*#__PURE__*/\nfunction () {\n  function ArrayWrapper(field, index, childSanitizations, dotPath) {\n    _classCallCheck(this, ArrayWrapper);\n\n    this.field = field;\n    this.index = index;\n    this.childSanitizations = childSanitizations;\n    this.dotPath = dotPath;\n    /**\n     * The pointer to read the value of the field inside the data tip\n     */\n\n    this.pointer = this.dotPath.concat(this.field).join('.');\n  }\n  /**\n   * Returns data copy to the passed to all the children of the array.\n   */\n\n\n  _createClass(ArrayWrapper, [{\n    key: \"getDataCopy\",\n    value: function getDataCopy(data) {\n      var value = lodash_get_1.default(data.tip, this.pointer);\n      /**\n       * Ensure value is array, otherwise skip the sanitization process.\n       */\n\n      if (!Array.isArray(value)) {\n        return null;\n      }\n      /**\n       * Since we are adding new properties to the data object. We have\n       * to create a new copy, otherwise the array specific values\n       * will leak this info to other sanitizations as well.\n       */\n\n\n      return {\n        original: data.original,\n        tip: null,\n        parentArray: value,\n        currentIndex: this.index === '*' ? 0 : Number(this.index)\n      };\n    }\n    /**\n     * Executes all sanitizations for a given index value inside the array.\n     */\n\n  }, {\n    key: \"executeSanitizations\",\n    value: function executeSanitizations(data, config) {\n      this.childSanitizations.forEach(function (sanitization) {\n        return sanitization.exec(data, config);\n      });\n    }\n    /**\n     * Execute series of sanitizations for values inside an array\n     */\n\n  }, {\n    key: \"exec\",\n    value: function exec(data, config) {\n      var _this = this;\n\n      var dataCopy = this.getDataCopy(data);\n\n      if (!dataCopy) {\n        return;\n      }\n      /**\n       * If index is a not a wildcard, then we run validations\n       * just for the given index.\n       */\n\n\n      if (this.index !== '*') {\n        dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n        return this.executeSanitizations(dataCopy, config);\n      }\n      /**\n       * Loop over all the entire array and execute validations\n       * for each field.\n       */\n\n\n      dataCopy.parentArray.forEach(function (item, index) {\n        dataCopy.tip = item;\n        dataCopy.currentIndex = index;\n\n        _this.executeSanitizations(dataCopy, config);\n      });\n    }\n  }]);\n\n  return ArrayWrapper;\n}();\n\nexports.ArrayWrapper = ArrayWrapper;","map":{"version":3,"sources":["/opt/lampp/htdocs/react-blog/node_modules/indicative-compiler/build/src/Sanitizer/ArrayWrapper.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","lodash_get_1","require","ArrayWrapper","field","index","childSanitizations","dotPath","pointer","concat","join","data","default","tip","Array","isArray","original","parentArray","currentIndex","Number","config","forEach","sanitization","exec","dataCopy","getDataCopy","executeSanitizations","item"],"mappings":"AAAA;AACA;;;;;;;;AAGA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA;;;;;;;;;AAQA,IAAMC,YAAY,GAAGP,eAAe,CAACQ,OAAO,CAAC,YAAD,CAAR,CAApC;AACA;;;;;;IAIMC,Y;;;AACF,wBAAYC,KAAZ,EAAmBC,KAAnB,EAA0BC,kBAA1B,EAA8CC,OAA9C,EAAuD;AAAA;;AACnD,SAAKH,KAAL,GAAaA,KAAb;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,kBAAL,GAA0BA,kBAA1B;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA;;;;AAGA,SAAKC,OAAL,GAAe,KAAKD,OAAL,CAAaE,MAAb,CAAoB,KAAKL,KAAzB,EAAgCM,IAAhC,CAAqC,GAArC,CAAf;AACH;AACD;;;;;;;gCAGYC,I,EAAM;AACd,UAAMX,KAAK,GAAGC,YAAY,CAACW,OAAb,CAAqBD,IAAI,CAACE,GAA1B,EAA+B,KAAKL,OAApC,CAAd;AACA;;;;AAGA,UAAI,CAACM,KAAK,CAACC,OAAN,CAAcf,KAAd,CAAL,EAA2B;AACvB,eAAO,IAAP;AACH;AACD;;;;;;;AAKA,aAAO;AACHgB,QAAAA,QAAQ,EAAEL,IAAI,CAACK,QADZ;AAEHH,QAAAA,GAAG,EAAE,IAFF;AAGHI,QAAAA,WAAW,EAAEjB,KAHV;AAIHkB,QAAAA,YAAY,EAAE,KAAKb,KAAL,KAAe,GAAf,GAAqB,CAArB,GAAyBc,MAAM,CAAC,KAAKd,KAAN;AAJ1C,OAAP;AAMH;AACD;;;;;;yCAGqBM,I,EAAMS,M,EAAQ;AAC/B,WAAKd,kBAAL,CAAwBe,OAAxB,CAAgC,UAACC,YAAD;AAAA,eAAkBA,YAAY,CAACC,IAAb,CAAkBZ,IAAlB,EAAwBS,MAAxB,CAAlB;AAAA,OAAhC;AACH;AACD;;;;;;yBAGKT,I,EAAMS,M,EAAQ;AAAA;;AACf,UAAMI,QAAQ,GAAG,KAAKC,WAAL,CAAiBd,IAAjB,CAAjB;;AACA,UAAI,CAACa,QAAL,EAAe;AACX;AACH;AACD;;;;;;AAIA,UAAI,KAAKnB,KAAL,KAAe,GAAnB,EAAwB;AACpBmB,QAAAA,QAAQ,CAACX,GAAT,GAAeW,QAAQ,CAACP,WAAT,CAAqBO,QAAQ,CAACN,YAA9B,CAAf;AACA,eAAO,KAAKQ,oBAAL,CAA0BF,QAA1B,EAAoCJ,MAApC,CAAP;AACH;AACD;;;;;;AAIAI,MAAAA,QAAQ,CAACP,WAAT,CAAqBI,OAArB,CAA6B,UAACM,IAAD,EAAOtB,KAAP,EAAiB;AAC1CmB,QAAAA,QAAQ,CAACX,GAAT,GAAec,IAAf;AACAH,QAAAA,QAAQ,CAACN,YAAT,GAAwBb,KAAxB;;AACA,QAAA,KAAI,CAACqB,oBAAL,CAA0BF,QAA1B,EAAoCJ,MAApC;AACH,OAJD;AAKH;;;;;;AAELrB,OAAO,CAACI,YAAR,GAAuBA,YAAvB","sourcesContent":["\"use strict\";\n/**\n * @module compiler/sanitizer\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Wraps an array of [[SanitizationsRunner]] and executes\n * them based upon the length of an data array at runtime.\n */\nclass ArrayWrapper {\n    constructor(field, index, childSanitizations, dotPath) {\n        this.field = field;\n        this.index = index;\n        this.childSanitizations = childSanitizations;\n        this.dotPath = dotPath;\n        /**\n         * The pointer to read the value of the field inside the data tip\n         */\n        this.pointer = this.dotPath.concat(this.field).join('.');\n    }\n    /**\n     * Returns data copy to the passed to all the children of the array.\n     */\n    getDataCopy(data) {\n        const value = lodash_get_1.default(data.tip, this.pointer);\n        /**\n         * Ensure value is array, otherwise skip the sanitization process.\n         */\n        if (!Array.isArray(value)) {\n            return null;\n        }\n        /**\n         * Since we are adding new properties to the data object. We have\n         * to create a new copy, otherwise the array specific values\n         * will leak this info to other sanitizations as well.\n         */\n        return {\n            original: data.original,\n            tip: null,\n            parentArray: value,\n            currentIndex: this.index === '*' ? 0 : Number(this.index),\n        };\n    }\n    /**\n     * Executes all sanitizations for a given index value inside the array.\n     */\n    executeSanitizations(data, config) {\n        this.childSanitizations.forEach((sanitization) => sanitization.exec(data, config));\n    }\n    /**\n     * Execute series of sanitizations for values inside an array\n     */\n    exec(data, config) {\n        const dataCopy = this.getDataCopy(data);\n        if (!dataCopy) {\n            return;\n        }\n        /**\n         * If index is a not a wildcard, then we run validations\n         * just for the given index.\n         */\n        if (this.index !== '*') {\n            dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n            return this.executeSanitizations(dataCopy, config);\n        }\n        /**\n         * Loop over all the entire array and execute validations\n         * for each field.\n         */\n        dataCopy.parentArray.forEach((item, index) => {\n            dataCopy.tip = item;\n            dataCopy.currentIndex = index;\n            this.executeSanitizations(dataCopy, config);\n        });\n    }\n}\nexports.ArrayWrapper = ArrayWrapper;\n"]},"metadata":{},"sourceType":"script"}