{"ast":null,"code":"\"use strict\";\n/**\n * @module compiler/validator\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Wraps the [[ValidationsRunner]] and executes them based upon the length of\n * an array at runtime.\n */\n\n\nclass ArrayWrapper {\n  constructor(field, index, childrenValidators, dotPath) {\n    this.field = field;\n    this.index = index;\n    this.childrenValidators = childrenValidators;\n    this.dotPath = dotPath;\n    /**\n     * The pointer to read the value of the field inside the data tip\n     */\n\n    this.pointer = this.dotPath.concat(this.field).join('.');\n    /**\n     * A boolean to know if any of the children inside the wrapper\n     * has async validators.\n     */\n\n    this.async = !!this.childrenValidators.find(validator => validator.async);\n  }\n  /**\n   * Returns data copy to the passed to all the children of the\n   * array.\n   */\n\n\n  getDataCopy(data) {\n    const value = lodash_get_1.default(data.tip, this.pointer);\n    /**\n     * Ensure value is array, otherwise mark the validation as passed.\n     * The top level value must be validated for an array for same.\n     */\n\n    if (!Array.isArray(value)) {\n      return null;\n    }\n    /**\n     * Since we are adding new properties to the data object. We have\n     * to create a new copy, otherwise the array specific values\n     * will leak this info to other validations as well.\n     */\n\n\n    return {\n      original: data.original,\n      pointer: '',\n      tip: null,\n      parentArray: value,\n      currentIndex: this.index === '*' ? 0 : Number(this.index),\n      arrayPointer: data.arrayPointer ? `${data.arrayPointer}.${data.currentIndex}.${this.pointer}` : this.pointer\n    };\n  }\n  /**\n   * Executes all validations for a given index value inside the array.\n   */\n\n\n  executeValidations(data, collector, config, bail) {\n    let hasFailures = false;\n\n    for (let validator of this.childrenValidators) {\n      const passed = validator.exec(data, collector, config, bail);\n\n      if (!passed) {\n        hasFailures = true;\n\n        if (bail) {\n          break;\n        }\n      }\n    }\n\n    return !hasFailures;\n  }\n  /**\n   * Same as [[ArrayWrapper.executeValidations]] but async.\n   */\n\n\n  async executeAsyncValidations(data, collector, config, bail) {\n    let hasFailures = false;\n\n    for (let validator of this.childrenValidators) {\n      let passed = true;\n\n      if (validator.async) {\n        passed = await validator.execAsync(data, collector, config, bail);\n      } else {\n        passed = validator.exec(data, collector, config, bail);\n      }\n\n      if (!passed) {\n        hasFailures = true;\n\n        if (bail) {\n          break;\n        }\n      }\n    }\n\n    return !hasFailures;\n  }\n  /**\n   * Execute series of validations for values inside an array\n   */\n\n\n  exec(data, collector, config, bail = false) {\n    const dataCopy = this.getDataCopy(data);\n\n    if (!dataCopy) {\n      return true;\n    }\n    /**\n     * If index is a not a wildcard, then we run validations\n     * just for the given index.\n     */\n\n\n    if (this.index !== '*') {\n      dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n      return this.executeValidations(dataCopy, collector, config, bail);\n    }\n\n    let index = 0;\n    let hasFailures = false;\n    /**\n     * Loop over all the entire array and execute validations\n     * for each field.\n     */\n\n    for (let item of dataCopy.parentArray) {\n      dataCopy.tip = item;\n      dataCopy.currentIndex = index;\n      let passed = true;\n      passed = this.executeValidations(dataCopy, collector, config, bail);\n\n      if (!passed) {\n        hasFailures = true;\n\n        if (bail) {\n          break;\n        }\n      }\n\n      index++;\n    }\n\n    return !hasFailures;\n  }\n  /**\n   * Execute series of async validations for values inside an array. Same\n   * as [[ArrayWrapper.exec]] but async.\n   */\n\n\n  async execAsync(data, collector, config, bail = false) {\n    const dataCopy = this.getDataCopy(data);\n\n    if (!dataCopy) {\n      return true;\n    }\n    /**\n     * If index is a not a wildcard, then we run validations\n     * just for the given index.\n     */\n\n\n    if (this.index !== '*') {\n      dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n      return this.executeAsyncValidations(dataCopy, collector, config, bail);\n    }\n\n    let index = 0;\n    let hasFailures = false;\n    /**\n     * Loop over all the entire array and execute validations\n     * for each field.\n     */\n\n    for (let item of dataCopy.parentArray) {\n      dataCopy.tip = item;\n      dataCopy.currentIndex = index;\n      const passed = await this.executeAsyncValidations(dataCopy, collector, config, bail);\n\n      if (!passed) {\n        hasFailures = true;\n\n        if (bail) {\n          break;\n        }\n      }\n\n      index++;\n    }\n\n    return !hasFailures;\n  }\n\n}\n\nexports.ArrayWrapper = ArrayWrapper;","map":{"version":3,"sources":["/opt/lampp/htdocs/blog-app/node_modules/indicative-compiler/build/src/Validator/ArrayWrapper.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","lodash_get_1","require","ArrayWrapper","constructor","field","index","childrenValidators","dotPath","pointer","concat","join","async","find","validator","getDataCopy","data","default","tip","Array","isArray","original","parentArray","currentIndex","Number","arrayPointer","executeValidations","collector","config","bail","hasFailures","passed","exec","executeAsyncValidations","execAsync","dataCopy","item"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @module compiler/validator\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Wraps the [[ValidationsRunner]] and executes them based upon the length of\n * an array at runtime.\n */\nclass ArrayWrapper {\n    constructor(field, index, childrenValidators, dotPath) {\n        this.field = field;\n        this.index = index;\n        this.childrenValidators = childrenValidators;\n        this.dotPath = dotPath;\n        /**\n         * The pointer to read the value of the field inside the data tip\n         */\n        this.pointer = this.dotPath.concat(this.field).join('.');\n        /**\n         * A boolean to know if any of the children inside the wrapper\n         * has async validators.\n         */\n        this.async = !!this.childrenValidators.find((validator) => validator.async);\n    }\n    /**\n     * Returns data copy to the passed to all the children of the\n     * array.\n     */\n    getDataCopy(data) {\n        const value = lodash_get_1.default(data.tip, this.pointer);\n        /**\n         * Ensure value is array, otherwise mark the validation as passed.\n         * The top level value must be validated for an array for same.\n         */\n        if (!Array.isArray(value)) {\n            return null;\n        }\n        /**\n         * Since we are adding new properties to the data object. We have\n         * to create a new copy, otherwise the array specific values\n         * will leak this info to other validations as well.\n         */\n        return {\n            original: data.original,\n            pointer: '',\n            tip: null,\n            parentArray: value,\n            currentIndex: this.index === '*' ? 0 : Number(this.index),\n            arrayPointer: data.arrayPointer\n                ? `${data.arrayPointer}.${data.currentIndex}.${this.pointer}`\n                : this.pointer,\n        };\n    }\n    /**\n     * Executes all validations for a given index value inside the array.\n     */\n    executeValidations(data, collector, config, bail) {\n        let hasFailures = false;\n        for (let validator of this.childrenValidators) {\n            const passed = validator.exec(data, collector, config, bail);\n            if (!passed) {\n                hasFailures = true;\n                if (bail) {\n                    break;\n                }\n            }\n        }\n        return !hasFailures;\n    }\n    /**\n     * Same as [[ArrayWrapper.executeValidations]] but async.\n     */\n    async executeAsyncValidations(data, collector, config, bail) {\n        let hasFailures = false;\n        for (let validator of this.childrenValidators) {\n            let passed = true;\n            if (validator.async) {\n                passed = await validator.execAsync(data, collector, config, bail);\n            }\n            else {\n                passed = validator.exec(data, collector, config, bail);\n            }\n            if (!passed) {\n                hasFailures = true;\n                if (bail) {\n                    break;\n                }\n            }\n        }\n        return !hasFailures;\n    }\n    /**\n     * Execute series of validations for values inside an array\n     */\n    exec(data, collector, config, bail = false) {\n        const dataCopy = this.getDataCopy(data);\n        if (!dataCopy) {\n            return true;\n        }\n        /**\n         * If index is a not a wildcard, then we run validations\n         * just for the given index.\n         */\n        if (this.index !== '*') {\n            dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n            return this.executeValidations(dataCopy, collector, config, bail);\n        }\n        let index = 0;\n        let hasFailures = false;\n        /**\n         * Loop over all the entire array and execute validations\n         * for each field.\n         */\n        for (let item of dataCopy.parentArray) {\n            dataCopy.tip = item;\n            dataCopy.currentIndex = index;\n            let passed = true;\n            passed = this.executeValidations(dataCopy, collector, config, bail);\n            if (!passed) {\n                hasFailures = true;\n                if (bail) {\n                    break;\n                }\n            }\n            index++;\n        }\n        return !hasFailures;\n    }\n    /**\n     * Execute series of async validations for values inside an array. Same\n     * as [[ArrayWrapper.exec]] but async.\n     */\n    async execAsync(data, collector, config, bail = false) {\n        const dataCopy = this.getDataCopy(data);\n        if (!dataCopy) {\n            return true;\n        }\n        /**\n         * If index is a not a wildcard, then we run validations\n         * just for the given index.\n         */\n        if (this.index !== '*') {\n            dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n            return this.executeAsyncValidations(dataCopy, collector, config, bail);\n        }\n        let index = 0;\n        let hasFailures = false;\n        /**\n         * Loop over all the entire array and execute validations\n         * for each field.\n         */\n        for (let item of dataCopy.parentArray) {\n            dataCopy.tip = item;\n            dataCopy.currentIndex = index;\n            const passed = await this.executeAsyncValidations(dataCopy, collector, config, bail);\n            if (!passed) {\n                hasFailures = true;\n                if (bail) {\n                    break;\n                }\n            }\n            index++;\n        }\n        return !hasFailures;\n    }\n}\nexports.ArrayWrapper = ArrayWrapper;\n"]},"metadata":{},"sourceType":"script"}