{"ast":null,"code":"\"use strict\";\n/**\n * @module compiler/main\n */\n\nvar _classCallCheck = require(\"/opt/lampp/htdocs/blog-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/lampp/htdocs/blog-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Tree walker is an agnostic implementation to walk over the parsed schema\n * tree generated by `indicative-parser`.\n *\n * The consumer of the code can define a function to consumer the tree nodes and\n * define another function to wrap the children of an array node.\n *\n * ## Why wrap array children?\n * Since the length of an array is unknown, until we receive the data at\n * runtime, we need a parent function (aka wrapper), that can execute\n * the child validations as per the length of the array.\n *\n * ```js\n * function consumerFn (\n *   field: string,\n *   rules: ParsedRule[],\n *   dotPath: string[],\n *   pointer: string,\n * ) {\n * }\n *\n * function arrayWrapper (\n *   index: string,\n *   field: string,\n *   children: ReturnType<consumerFn>[],\n *   dotPath: string[],\n * ) {\n * }\n *\n * new TreeWalker(consumerFn, arrayWrapper).walk(parsedSchema)\n * ```\n */\n\nvar TreeWalker =\n/*#__PURE__*/\nfunction () {\n  function TreeWalker(consumerFn, arrayWrapper) {\n    _classCallCheck(this, TreeWalker);\n\n    this.consumerFn = consumerFn;\n    this.arrayWrapper = arrayWrapper;\n  }\n  /**\n   * Processes the literal node inside schema tree\n   */\n\n\n  _createClass(TreeWalker, [{\n    key: \"processLiteralNode\",\n    value: function processLiteralNode(field, node, dotPath, arrayPath) {\n      var pointer = arrayPath.concat(dotPath).concat(field).join('.');\n      return this.consumerFn(field, node.type, node.rules, dotPath, pointer);\n    }\n    /**\n     * Process the object node inside the parsed. All children are parsed\n     * recursively\n     */\n\n  }, {\n    key: \"processObjectNode\",\n    value: function processObjectNode(field, node, dotPath, arrayPath) {\n      var output = [];\n      /**\n       * If object itself has rules, then we need to consume that\n       * as well.\n       */\n\n      if (node.rules.length) {\n        var pointer = arrayPath.concat(dotPath).concat(field).join('.');\n        output.push(this.consumerFn(field, node.type, node.rules, dotPath, pointer));\n      }\n      /**\n       * Walker over object children\n       */\n\n\n      output = output.concat(this.walk(node.children, dotPath.concat(field), arrayPath));\n      return output;\n    }\n    /**\n     * Process the array node of the schema tree. This method will call\n     * the `arrayWrapper` function and passes all array children to it.\n     */\n\n  }, {\n    key: \"processArrayNode\",\n    value: function processArrayNode(field, node, dotPath, arrayPath) {\n      var _this = this;\n\n      var output = [];\n      var basePath = arrayPath.concat(dotPath).concat(field);\n      /**\n       * If array itself has rules, then we need to process that\n       * as well\n       */\n\n      if (node.rules.length) {\n        var pointer = basePath.join('.');\n        output.push(this.consumerFn(field, node.type, node.rules, dotPath, pointer));\n      }\n      /**\n       * Processing children for each index. The index of the tree can be a\n       * wildcard `*`, which means we rely on runtime data to know the\n       * actual length of the array.\n       */\n\n\n      Object.keys(node.each).forEach(function (index) {\n        var child = [];\n\n        if (node.each[index].rules.length) {\n          var _pointer = basePath.concat(index).join('.');\n\n          child.push(_this.consumerFn('::tip::', 'literal', node.each[index].rules, [], _pointer));\n        }\n\n        child = child.concat(_this.walk(node.each[index].children, [], basePath.concat(index)));\n        output = output.concat(_this.arrayWrapper(index, field, child, dotPath));\n      });\n      return output;\n    }\n    /**\n     * Walks the schema tree and invokes the `consumerFn` for each node.\n     * The output of the consumer is collected and returned back as an\n     * array.\n     */\n\n  }, {\n    key: \"walk\",\n    value: function walk(schema) {\n      var _this2 = this;\n\n      var dotPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var arrayPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      return Object.keys(schema).reduce(function (result, field) {\n        var node = schema[field];\n\n        if (node.type === 'literal') {\n          result = result.concat(_this2.processLiteralNode(field, node, dotPath, arrayPath));\n        }\n\n        if (node.type === 'object') {\n          result = result.concat(_this2.processObjectNode(field, node, dotPath, arrayPath));\n        }\n\n        if (node.type === 'array') {\n          result = result.concat(_this2.processArrayNode(field, node, dotPath, arrayPath));\n        }\n\n        return result;\n      }, []);\n    }\n  }]);\n\n  return TreeWalker;\n}();\n\nexports.TreeWalker = TreeWalker;","map":{"version":3,"sources":["/opt/lampp/htdocs/blog-app/node_modules/indicative-compiler/build/src/TreeWalker/index.js"],"names":["Object","defineProperty","exports","value","TreeWalker","consumerFn","arrayWrapper","field","node","dotPath","arrayPath","pointer","concat","join","type","rules","output","length","push","walk","children","basePath","keys","each","forEach","index","child","schema","reduce","result","processLiteralNode","processObjectNode","processArrayNode"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @module compiler/main\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Tree walker is an agnostic implementation to walk over the parsed schema\n * tree generated by `indicative-parser`.\n *\n * The consumer of the code can define a function to consumer the tree nodes and\n * define another function to wrap the children of an array node.\n *\n * ## Why wrap array children?\n * Since the length of an array is unknown, until we receive the data at\n * runtime, we need a parent function (aka wrapper), that can execute\n * the child validations as per the length of the array.\n *\n * ```js\n * function consumerFn (\n *   field: string,\n *   rules: ParsedRule[],\n *   dotPath: string[],\n *   pointer: string,\n * ) {\n * }\n *\n * function arrayWrapper (\n *   index: string,\n *   field: string,\n *   children: ReturnType<consumerFn>[],\n *   dotPath: string[],\n * ) {\n * }\n *\n * new TreeWalker(consumerFn, arrayWrapper).walk(parsedSchema)\n * ```\n */\nclass TreeWalker {\n    constructor(consumerFn, arrayWrapper) {\n        this.consumerFn = consumerFn;\n        this.arrayWrapper = arrayWrapper;\n    }\n    /**\n     * Processes the literal node inside schema tree\n     */\n    processLiteralNode(field, node, dotPath, arrayPath) {\n        const pointer = arrayPath.concat(dotPath).concat(field).join('.');\n        return this.consumerFn(field, node.type, node.rules, dotPath, pointer);\n    }\n    /**\n     * Process the object node inside the parsed. All children are parsed\n     * recursively\n     */\n    processObjectNode(field, node, dotPath, arrayPath) {\n        let output = [];\n        /**\n         * If object itself has rules, then we need to consume that\n         * as well.\n         */\n        if (node.rules.length) {\n            const pointer = arrayPath.concat(dotPath).concat(field).join('.');\n            output.push(this.consumerFn(field, node.type, node.rules, dotPath, pointer));\n        }\n        /**\n         * Walker over object children\n         */\n        output = output.concat(this.walk(node.children, dotPath.concat(field), arrayPath));\n        return output;\n    }\n    /**\n     * Process the array node of the schema tree. This method will call\n     * the `arrayWrapper` function and passes all array children to it.\n     */\n    processArrayNode(field, node, dotPath, arrayPath) {\n        let output = [];\n        const basePath = arrayPath.concat(dotPath).concat(field);\n        /**\n         * If array itself has rules, then we need to process that\n         * as well\n         */\n        if (node.rules.length) {\n            const pointer = basePath.join('.');\n            output.push(this.consumerFn(field, node.type, node.rules, dotPath, pointer));\n        }\n        /**\n         * Processing children for each index. The index of the tree can be a\n         * wildcard `*`, which means we rely on runtime data to know the\n         * actual length of the array.\n         */\n        Object.keys(node.each).forEach((index) => {\n            let child = [];\n            if (node.each[index].rules.length) {\n                const pointer = basePath.concat(index).join('.');\n                child.push(this.consumerFn('::tip::', 'literal', node.each[index].rules, [], pointer));\n            }\n            child = child.concat(this.walk(node.each[index].children, [], basePath.concat(index)));\n            output = output.concat(this.arrayWrapper(index, field, child, dotPath));\n        });\n        return output;\n    }\n    /**\n     * Walks the schema tree and invokes the `consumerFn` for each node.\n     * The output of the consumer is collected and returned back as an\n     * array.\n     */\n    walk(schema, dotPath = [], arrayPath = []) {\n        return Object.keys(schema).reduce((result, field) => {\n            const node = schema[field];\n            if (node.type === 'literal') {\n                result = result.concat(this.processLiteralNode(field, node, dotPath, arrayPath));\n            }\n            if (node.type === 'object') {\n                result = result.concat(this.processObjectNode(field, node, dotPath, arrayPath));\n            }\n            if (node.type === 'array') {\n                result = result.concat(this.processArrayNode(field, node, dotPath, arrayPath));\n            }\n            return result;\n        }, []);\n    }\n}\nexports.TreeWalker = TreeWalker;\n"]},"metadata":{},"sourceType":"script"}